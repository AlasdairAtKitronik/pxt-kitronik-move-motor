<xml xmlns="https://developers.google.com/blockly/xml"><comment id="2v%yxqT5i+$D9[#aV/#[" w="480" data="0" y="203" x="588" h="120">Blocks for driving the Kitronik MOVE Motor Board</comment><block id="I;9F7[(m;bov^XwG|/Na" type="pxt-on-start" y="0" x="0"><statement name="HANDLER"><block id="%BA-I8,Lxrh4m#.[+W1V" type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line778="}" line777="" numlines="779" line0="namespace Kitronik_Move_Motor {" line1="    //Constants " line2="    let CHIP_ADDR = 0xE0 // CHIP_ADDR is the standard chip address for the PCA9632" line3="    let MODE_1_REG_ADDR = 0x00 //mode 1 register address" line4="    let MODE_2_REG_ADDR = 0x01  //mode 2 register address" line5="    let LED_OUT_ADDR = 0x08  //LED output register address" line6="" line7="    let MODE_1_REG_VALUE = 0x00 //the prescale register address" line8="    let MODE_2_REG_VALUE = 0x10  //The mode 1 register address" line9="    let LED_OUT_VALUE = 0xAA  //The mode 1 register address" line10="" line11="    let MOTOR_DUTY_CYCLE_RATION = 0.4" line12="" line13="    /*GENERAL*/" line14="    export enum OnOffSelection {" line15="        //% block=&quot;on&quot;" line16="        On = 1," line17="        //% block=&quot;off&quot;" line18="        Off = 0" line19="    }" line20="" line21="    /* ZIPLEDS*/" line22="    //Well known colors for ZIP LEDs" line23="    enum ZipLedColors {" line24="        //% block=red" line25="        Red = 0xFF0000," line26="        //% block=orange" line27="        Orange = 0xFFA500," line28="        //% block=yellow" line29="        Yellow = 0xFFFF00," line30="        //% block=green" line31="        Green = 0x00FF00," line32="        //% block=blue" line33="        Blue = 0x0000FF," line34="        //% block=indigo" line35="        Indigo = 0x4b0082," line36="        //% block=violet" line37="        Violet = 0x8a2be2," line38="        //% block=purple" line39="        Purple = 0xFF00FF," line40="        //% block=white" line41="        White = 0xFFFFFF," line42="        //% block=black" line43="        Black = 0x000000" line44="    }" line45="" line46="    /*MOTORS*/" line47="    // List of motors for the motor blocks to use. These represent register offsets in the PCA9865 driver IC." line48="    export enum Motors {" line49="        //% block=&quot;Left&quot;" line50="        MotorLeft = 0x02," line51="        //% block=&quot;Right&quot;" line52="        MotorRight = 0x04" line53="    }" line54="    // Directions the motors can rotate." line55="    export enum MotorDirection {" line56="        //% block=&quot;Forward&quot;" line57="        Forward," line58="        //% block=&quot;Reverse&quot;" line59="        Reverse" line60="    }" line61="" line62="    /*ULTRASONIC*/" line63="    // Units for ultrasonic sensors to measure" line64="    export enum Units {" line65="        //% block=&quot;cm&quot;" line66="        Centimeters," line67="        //% block=&quot;inches&quot;" line68="        Inches" line69="    }" line70="" line71="    /*LINE FOLLOWING*/" line72="    // Selection of line following sensor" line73="    export enum LfSensor {" line74="        //% block=&quot;left&quot;" line75="        left," line76="        //% block=&quot;right&quot;" line77="        right" line78="    }" line79="    //Light level detection mode selection" line80="    export enum LightSelection {" line81="        //% block=&quot;Light&quot;" line82="        Light," line83="        //% block=&quot;Dark&quot;" line84="        Dark" line85="    }" line86="" line87="    let initalised = false //a flag to allow us to initialise without explicitly calling the secret incantation" line88="    //Motor global variables" line89="    let sirenOn = false" line90="    //Ultrasonic global variables" line91="    let triggerPin = DigitalPin.P13" line92="    let echoPin = DigitalPin.P14" line93="    //Line following sensors global variables" line94="    let sensorLeftRef = 0" line95="    let sensorRightRef = 0" line96="    let detectionLevel = 45&#9;&#9;//reading is done by converting 0.13V into ADC reading (3/1024)*45, this is the default setting" line97="" line98="" line99="&#9;/*" line100="&#9;&#9;This secret incantation sets up the PCA9632 I2C driver chip to be running " line101="    */" line102="    function setup(): void {" line103="        let buf = pins.createBuffer(2)" line104="" line105="        buf[0] = MODE_1_REG_ADDR" line106="        buf[1] = MODE_1_REG_VALUE" line107="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line108="        buf[0] = MODE_2_REG_ADDR" line109="        buf[1] = MODE_2_REG_VALUE" line110="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line111="        buf[0] = LED_OUT_ADDR" line112="        buf[1] = LED_OUT_VALUE" line113="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line114="" line115="        sensorLeftRef = pins.analogReadPin(AnalogPin.P1)" line116="        sensorRightRef = pins.analogReadPin(AnalogPin.P2)" line117="        initalised = true" line118="    }" line119="" line120="    //////////////" line121="    //  LIGHTS  //" line122="    //////////////" line123="" line124="    /**" line125="    * Turns on and off the horn." line126="    * @param motor which motor to turn off" line127="    */" line128="    //% subcategory=Lights" line129="    //% group=&quot;Tail Lights&quot;" line130="    //% blockId=kitronik_move_motor_tail_light" line131="    //% weight=95 blockGap=8" line132="    //% block=&quot;turn tail light %illuminate&quot;" line133="    export function shineTailLight(illuminate: OnOffSelection): void {" line134="        if (illuminate == OnOffSelection.On) {" line135="            pins.digitalWritePin(DigitalPin.P12, 1);" line136="        }" line137="        else {" line138="            pins.digitalWritePin(DigitalPin.P12, 0);" line139="        }" line140="    }" line141="" line142="    export class MoveMotorZIP {" line143="        buf: Buffer;" line144="        pin: DigitalPin;" line145="        brightness: number;" line146="        start: number;" line147="        _length: number;" line148="" line149="" line150="        /**" line151="         * Shows a rainbow pattern on all LEDs. " line152="         * @param startHue the start hue value for the rainbow, eg: 1" line153="         * @param endHue the end hue value for the rainbow, eg: 360" line154="         */" line155="        //% subcategory=Lights" line156="        //% group=&quot;ZIP LEDs&quot;" line157="        //% blockId=&quot;kitronik_move_motor_rainbow&quot; 7" line158="        //% block=&quot;%moveMotorZIP|show rainbow from %startHue|to %endHue&quot;" line159="        //% weight=94 blockGap=8" line160="        showRainbow(startHue: number = 1, endHue: number = 360) {" line161="            if (this._length &lt;= 0) return;" line162="" line163="            startHue = startHue &gt;&gt; 0;" line164="            endHue = endHue &gt;&gt; 0;" line165="            const saturation = 100;" line166="            const luminance = 50;" line167="            const steps = this._length;" line168="            const direction = HueInterpolationDirection.Clockwise;" line169="" line170="            //hue" line171="            const h1 = startHue;" line172="            const h2 = endHue;" line173="            const hDistCW = ((h2 + 360) - h1) % 360;" line174="            const hStepCW = Math.idiv((hDistCW * 100), steps);" line175="            const hDistCCW = ((h1 + 360) - h2) % 360;" line176="            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line177="            let hStep: number;" line178="            if (direction === HueInterpolationDirection.Clockwise) {" line179="                hStep = hStepCW;" line180="            } else if (direction === HueInterpolationDirection.CounterClockwise) {" line181="                hStep = hStepCCW;" line182="            } else {" line183="                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line184="            }" line185="            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line186="" line187="            //sat" line188="            const s1 = saturation;" line189="            const s2 = saturation;" line190="            const sDist = s2 - s1;" line191="            const sStep = Math.idiv(sDist, steps);" line192="            const s1_100 = s1 * 100;" line193="" line194="            //lum" line195="            const l1 = luminance;" line196="            const l2 = luminance;" line197="            const lDist = l2 - l1;" line198="            const lStep = Math.idiv(lDist, steps);" line199="            const l1_100 = l1 * 100" line200="" line201="            //interpolate" line202="            if (steps === 1) {" line203="                this.setPixelRGB(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line204="            } else {" line205="                this.setPixelRGB(0, hsl(startHue, saturation, luminance));" line206="                for (let i = 1; i &lt; steps - 1; i++) {" line207="                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;" line208="                    const s = Math.idiv((s1_100 + i * sStep), 100);" line209="                    const l = Math.idiv((l1_100 + i * lStep), 100);" line210="                    this.setPixelRGB(i, hsl(h, s, l));" line211="                }" line212="                this.setPixelRGB(steps - 1, hsl(endHue, saturation, luminance));" line213="            }" line214="            this.show();" line215="        }" line216="" line217="&#9;&#9;/**" line218="         * Displays a vertical bar graph based on the `value` and `high` value." line219="         * If `high` is 0, the chart gets adjusted automatically." line220="         * @param value current value to plot" line221="         * @param high maximum value, eg: 255" line222="         */" line223="        //% subcategory=Lights" line224="        //% group=&quot;ZIP LEDs&quot;" line225="        //% weight=84 blockGap=8" line226="        //% blockId=kitronik_move_motor_show_bar_graph " line227="        //% block=&quot;%moveMotorZIP|show bar graph of %value|up to %high&quot;" line228="        showBarGraph(value: number, high: number): void {" line229="            if (high &lt;= 0) {" line230="                this.clear();" line231="                this.setPixelRGB(0, 0xFFFF00);" line232="                this.show();" line233="                return;" line234="            }" line235="" line236="            value = Math.abs(value);" line237="            const n = this._length;" line238="            const n1 = n - 1;" line239="            let v = Math.idiv((value * n), high);" line240="            if (v == 0) {" line241="                this.setPixelRGB(0, 0x666600);" line242="                for (let j = 1; j &lt; n; ++j)" line243="                    this.setPixelRGB(j, 0);" line244="            } else {" line245="                for (let k = 0; k &lt; n; ++k) {" line246="                    if (k &lt;= v) {" line247="                        const g = Math.idiv(k * 255, n1);" line248="                        //this.setPixelRGB(i, moveMotorZIP.rgb(0, g, 255 - g));" line249="                        this.setPixelRGB(k, rgb(g, 255 - g, 0));" line250="                    }" line251="                    else this.setPixelRGB(k, 0);" line252="                }" line253="            }" line254="            this.show();" line255="        }" line256="" line257="        /** " line258="        * Create a range of LEDs." line259="        * @param start offset in the LED strip to start the range" line260="        * @param length number of LEDs in the range. eg: 4" line261="        */" line262="        //% subcategory=Lights" line263="        //% group=&quot;ZIP LEDs&quot;" line264="        //% weight=89 blockGap=8" line265="        //% blockId=&quot;kitronik_move_motor_range&quot; " line266="        //% block=&quot;%moveMotorZIP|range from %start|with %length|leds&quot;" line267="        range(start: number, length: number): MoveMotorZIP {" line268="            start = start &gt;&gt; 0;" line269="            length = length &gt;&gt; 0;" line270="            let moveMotorZIP = new MoveMotorZIP();" line271="            moveMotorZIP.buf = this.buf;" line272="            moveMotorZIP.pin = this.pin;" line273="            moveMotorZIP.brightness = this.brightness;" line274="            moveMotorZIP.start = this.start + Math.clamp(0, this._length - 1, start);" line275="            moveMotorZIP._length = Math.clamp(0, this._length - (moveMotorZIP.start - this.start), length);" line276="            return moveMotorZIP;" line277="        }" line278="" line279="        /**" line280="         * Rotate LEDs forward." line281="         * You need to call ``show`` to make the changes visible." line282="         * @param offset number of ZIP LEDs to rotate forward, eg: 1" line283="         */" line284="        //% subcategory=Lights" line285="        //% group=&quot;ZIP LEDs&quot;" line286="        //% blockId=&quot;kitronik_move_motor_display_rotate&quot; " line287="        //% block=&quot;%moveMotorZIP|rotate ZIP LEDs by %offset&quot; " line288="        //% weight=93 blockGap=8" line289="        rotate(offset: number = 1): void {" line290="            this.buf.rotate(-offset * 3, this.start * 3, this._length * 3)" line291="        }" line292="    &#9;/**" line293="         * Sets whole ZIP Halo display as a given color (range 0-255 for r, g, b). Call Show to make changes visible " line294="         * @param rgb RGB color of the LED" line295="         */" line296="        //% subcategory=Lights" line297="        //% group=&quot;ZIP LEDs&quot;" line298="        //% blockId=&quot;kitronik_move_motor_display_only_set_strip_color&quot; " line299="        //% block=&quot;%moveMotorZIP|set color %rgb=kitronik_move_motor_colors&quot;" line300="        //% weight=99 blockGap=8" line301="        setColor(rgb: number) {" line302="            rgb = rgb &gt;&gt; 0;" line303="            this.setAllRGB(rgb);" line304="        }" line305="    &#9;/**" line306="         * Shows whole ZIP Halo display as a given color (range 0-255 for r, g, b). " line307="         * @param rgb RGB color of the LED" line308="         */" line309="        //% subcategory=Lights" line310="        //% group=&quot;ZIP LEDs&quot;" line311="        //% blockId=&quot;kitronik_move_motor_display_set_strip_color&quot; " line312="        //% block=&quot;%moveMotorZIP|show color %rgb=kitronik_move_motor_colors&quot;" line313="        //% weight=99 blockGap=8" line314="        showColor(rgb: number) {" line315="            rgb = rgb &gt;&gt; 0;" line316="            this.setAllRGB(rgb);" line317="            this.show();" line318="        }" line319="" line320="        /**" line321="         * Set particular ZIP LED to a given color. " line322="         * You need to call ``show changes`` to make the changes visible." line323="         * @param zipLedNum position of the ZIP LED in the string" line324="         * @param rgb RGB color of the ZIP LED" line325="         */" line326="        //% subcategory=Lights" line327="        //% group=&quot;ZIP LEDs&quot;" line328="        //% blockId=&quot;kitronik_move_motor_set_zip_color&quot; " line329="        //% block=&quot;%moveMotorZIP|set ZIP LED %zipLedNum|to %rgb=kitronik_move_motor_colors&quot;" line330="        //% weight=98 blockGap=8" line331="        setZipLedColor(zipLedNum: number, rgb: number): void {" line332="            this.setPixelRGB(zipLedNum &gt;&gt; 0, rgb &gt;&gt; 0);" line333="        }" line334="" line335="        /**" line336="         * Send all the changes to the ZIP Halo display." line337="         */" line338="        //% subcategory=Lights" line339="        //% group=&quot;ZIP LEDs&quot;" line340="        //% blockId=&quot;kitronik_move_motor_display_show&quot; " line341="        //% block=&quot;%moveMotorZIP|show&quot; blockGap=8" line342="        //% weight=96" line343="        show() {" line344="            //use the Kitronik version which respects brightness for all " line345="            ws2812b.sendBuffer(this.buf, this.pin, this.brightness);" line346="        }" line347="" line348="        /**" line349="         * Turn off all LEDs on the ZIP Halo display." line350="         * You need to call ``show`` to make the changes visible." line351="         */" line352="        //% subcategory=Lights" line353="        //% group=&quot;ZIP LEDs&quot;" line354="        //% blockId=&quot;kitronik_move_motor_display_clear&quot;" line355="        //% block=&quot;%moveMotorZIP|clear&quot;" line356="        //% weight=95 blockGap=8" line357="        clear(): void {" line358="            this.buf.fill(0, this.start * 3, this._length * 3);" line359="        }" line360="" line361="        /**" line362="         * Set the brightness of the ZIP Halo display. This flag only applies to future show operation." line363="         * @param brightness a measure of LED brightness in 0-255. eg: 255" line364="         */" line365="        //% subcategory=Lights" line366="        //% group=&quot;ZIP LEDs&quot;" line367="        //% blockId=&quot;kitronik_move_motordisplay_set_brightness&quot;" line368="        //% block=&quot;%moveMotorZIP|set brightness %brightness&quot; " line369="        //% weight=92 blockGap=8" line370="        //% brightness.min=0 brightness.max=255" line371="        setBrightness(brightness: number): void {" line372="            //Clamp incoming variable at 0-255 as values out of this range cause unexpected brightnesses as the lower level code only expects a byte." line373="            if (brightness &lt; 0) {" line374="                brightness = 0" line375="            }" line376="            else if (brightness &gt; 255) {" line377="                brightness = 255" line378="            }" line379="            this.brightness = brightness &amp; 0xff;" line380="            basic.pause(1) //add a pause to stop wierdnesses" line381="        }" line382="" line383="        //Sets up the buffer for pushing LED control data out to LEDs" line384="        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {" line385="            this.buf[offset + 0] = green;" line386="            this.buf[offset + 1] = red;" line387="            this.buf[offset + 2] = blue;" line388="        }" line389="" line390="        //Separates out Red, Green and Blue data and fills the LED control data buffer for all LEDs" line391="        private setAllRGB(rgb: number) {" line392="            let red = unpackR(rgb);" line393="            let green = unpackG(rgb);" line394="            let blue = unpackB(rgb);" line395="" line396="            const end = this.start + this._length;" line397="            for (let m = this.start; m &lt; end; ++m) {" line398="                this.setBufferRGB(m * 3, red, green, blue)" line399="            }" line400="        }" line401="" line402="        //Separates out Red, Green and Blue data and fills the LED control data buffer for a single LED" line403="        private setPixelRGB(pixeloffset: number, rgb: number): void {" line404="            if (pixeloffset &lt; 0" line405="                || pixeloffset &gt;= this._length)" line406="                return;" line407="" line408="            pixeloffset = (pixeloffset + this.start) * 3;" line409="" line410="            let red2 = unpackR(rgb);" line411="            let green2 = unpackG(rgb);" line412="            let blue2 = unpackB(rgb);" line413="" line414="            this.setBufferRGB(pixeloffset, red2, green2, blue2)" line415="        }" line416="    }" line417="" line418="    /**" line419="     * Create a new ZIP LED driver for MOVE Motor board." line420="&#9; * @param numZips number of leds in the strip, eg: 4" line421="     */" line422="    //% subcategory=Lights" line423="    //% group=&quot;ZIP LEDs&quot;" line424="    //% blockId=&quot;kitronik_move_motor_ZIP_LED_create&quot; " line425="    //% block=&quot;to Halo HD with %numZips|ZIP LEDs&quot;" line426="    //% weight=100 blockGap=8" line427="    //% trackArgs=0,2" line428="    //% blockSetVariable=moveMotorZIP" line429="    export function createMoveMotorZIPLED(numZips: number): MoveMotorZIP {" line430="        let moveMotorZIP2 = new MoveMotorZIP();" line431="        moveMotorZIP2.buf = pins.createBuffer(numZips * 3);" line432="        moveMotorZIP2.start = 0;" line433="        moveMotorZIP2._length = numZips;" line434="        moveMotorZIP2.setBrightness(128)" line435="        moveMotorZIP2.pin = DigitalPin.P8;" line436="        pins.digitalWritePin(moveMotorZIP2.pin, 8);" line437="        return moveMotorZIP2;" line438="    }" line439="" line440="    /*  The LEDs we are using have centre wavelengths of 470nm (Blue) 525nm(Green) and 625nm (Red) " line441="    * &#9; We blend these linearly to give the impression of the other wavelengths. " line442="    *   as we cant wavelength shift an actual LED... (Ye canna change the laws of physics Capt)*/" line443="" line444="    /**" line445="     * Converts value to red, green, blue channels" line446="     * @param red value of the red channel between 0 and 255. eg: 255" line447="     * @param green value of the green channel between 0 and 255. eg: 255" line448="     * @param blue value of the blue channel between 0 and 255. eg: 255" line449="     */" line450="    //% subcategory=Lights" line451="    //% group=&quot;ZIP LEDs&quot;" line452="    //% weight=1 blockGap=8" line453="    //% blockId=&quot;kitronik_move_motor_rgb&quot; block=&quot;red %red|green %green|blue %blue&quot;" line454="    export function rgb(red: number, green: number, blue: number): number {" line455="        return packRGB(red, green, blue);" line456="    }" line457="" line458="    /**" line459="     * Gets the RGB value of a known color" line460="    */" line461="    //% subcategory=Lights" line462="    //% group=&quot;ZIP LEDs&quot;" line463="    //% weight=2 blockGap=8" line464="    //% blockId=&quot;kitronik_move_motor_colors&quot; block=&quot;%color&quot;" line465="    export function colors(color: ZipLedColors): number {" line466="        return color;" line467="    }" line468="" line469="    //Combines individual RGB settings to be a single number" line470="    function packRGB(a: number, b: number, c: number): number {" line471="        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);" line472="    }" line473="    //Separates red value from combined number" line474="    function unpackR(rgb: number): number {" line475="        let r = (rgb &gt;&gt; 16) &amp; 0xFF;" line476="        return r;" line477="    }" line478="    //Separates green value from combined number" line479="    function unpackG(rgb: number): number {" line480="        let o = (rgb &gt;&gt; 8) &amp; 0xFF;" line481="        return o;" line482="    }" line483="    //Separates blue value from combined number" line484="    function unpackB(rgb: number): number {" line485="        let b = (rgb) &amp; 0xFF;" line486="        return b;" line487="    }" line488="" line489="    /**" line490="     * Converts a hue saturation luminosity value into a RGB color" line491="     */" line492="    function hsl(h: number, s: number, l: number): number {" line493="        h = Math.round(h);" line494="        s = Math.round(s);" line495="        l = Math.round(l);" line496="" line497="        h = h % 360;" line498="        s = Math.clamp(0, 99, s);" line499="        l = Math.clamp(0, 99, l);" line500="        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line501="        let h12 = Math.idiv(h, 60);//[0,6]" line502="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line503="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line504="        let x = (c * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line505="        let r$: number;" line506="        let g$: number;" line507="        let b$: number;" line508="        if (h12 == 0) {" line509="            r$ = c; g$ = x; b$ = 0;" line510="        } else if (h12 == 1) {" line511="            r$ = x; g$ = c; b$ = 0;" line512="        } else if (h12 == 2) {" line513="            r$ = 0; g$ = c; b$ = x;" line514="        } else if (h12 == 3) {" line515="            r$ = 0; g$ = x; b$ = c;" line516="        } else if (h12 == 4) {" line517="            r$ = x; g$ = 0; b$ = c;" line518="        } else if (h12 == 5) {" line519="            r$ = c; g$ = 0; b$ = x;" line520="        }" line521="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c), 2);" line522="        let t = r$ + p;" line523="        let q = g$ + p;" line524="        let d = b$ + p;" line525="        return packRGB(t, q, d);" line526="    }" line527="" line528="    /**" line529="     * Options for direction hue changes, used by rainbow block (never visible to end user)" line530="     */" line531="    export enum HueInterpolationDirection {" line532="        Clockwise," line533="        CounterClockwise," line534="        Shortest" line535="    }" line536="" line537="    //////////////" line538="    //  SENSORS //" line539="    //////////////" line540="    /**" line541="     * Measure the echo time (after trigger) and converts to cm or inches and returns as an int" line542="     * @param unit desired conversion unit" line543="     * @param maxCmDistance maximum distance in centimeters (default is 500)" line544="     */" line545="    //% subcategory=Sensors" line546="    //% group=&quot;Ultrasonic&quot;" line547="    //% blockId=kitronik_move_motor_ultrasonic_measure" line548="    //% block=&quot;measure distances in |unit %unit&quot;" line549="    export function measure(unit: Units, maxCmDistance = 500): number {" line550="        // send pulse" line551="        pins.setPull(triggerPin, PinPullMode.PullNone);" line552="        pins.digitalWritePin(triggerPin, 0);" line553="        control.waitMicros(2);" line554="        pins.digitalWritePin(triggerPin, 1);" line555="        control.waitMicros(10);" line556="        pins.digitalWritePin(triggerPin, 0);" line557="" line558="        // read pulse" line559="        const pulse = pins.pulseIn(echoPin, PulseValue.High, maxCmDistance * 39);" line560="        switch (unit) {" line561="            case Units.Centimeters: return Math.idiv(pulse, 39);" line562="            case Units.Inches: return Math.idiv(pulse, 98);" line563="            default: return 0;" line564="        }" line565="    }" line566="" line567="" line568="    /**" line569="    * Set sensor threshold block allows the user to adjust the point at which the sensor detects" line570="    * @param level is the threshold percentage" line571="    */" line572="    //% subcategory=Sensors" line573="    //% group=&quot;Line Following&quot;" line574="    //% blockId=kitronik_move_motor_line_follower_set_threshold" line575="    //% block=&quot;set sensor threshold to %level|&quot;" line576="    //% level.min=0 level.max=100 level.defl=50" line577="    //% weight=85 blockGap=8" line578="    export function setSensorDetectionLevel(level: number) {" line579="        if (initalised == false) {" line580="            setup()" line581="        }" line582="        detectionLevel = (level / 2) + 10" line583="    }" line584="" line585="    /**" line586="    * Read sensor block allows user to read the value of the sensor (returns value in range 0-1023)" line587="    * @param pinSelected is the selection of pin to read a particular sensor" line588="    */" line589="    //% subcategory=Sensors" line590="    //% group=&quot;Line Following&quot;" line591="    //% blockId=kitronik_move_motor_line_follower_read_sensor" line592="    //% block=&quot;read sensor on pin %pinSelected&quot;" line593="    //% weight=90 blockGap=8" line594="    export function readSensor(sensorSelected: LfSensor) {" line595="        let value = 0" line596="" line597="        if (initalised == false) {" line598="            setup()" line599="        }" line600="" line601="        if (sensorSelected == LfSensor.left) {" line602="            value = pins.analogReadPin(AnalogPin.P1)" line603="        }" line604="        else if (sensorSelected == LfSensor.right) {" line605="            value = pins.analogReadPin(AnalogPin.P1)" line606="        }" line607="        return value;" line608="    }" line609="" line610="    /**" line611="    * Sensor on pin detection returns a true or false when the sensor has detected" line612="    * @param pinSelected is the selection of pin to read a particular sensor" line613="&#9;* @param lightSelection is the selection of the sensor detecting light or dark" line614="    */" line615="    //% subcategory=Sensors" line616="    //% group=&quot;Line Following&quot;" line617="    //% blockId=kitronik_move_motor_line_follower_digital_sensor" line618="    //% block=&quot;sensor on pin %pinSelected| detected %LightSelection&quot;" line619="    //% weight=95 blockGap=8" line620="    export function sensorDigitalDetection(pinSelected: LfSensor, lightLevel: LightSelection): boolean {" line621="        let value2 = 0" line622="        let ref = 0" line623="        let result = false" line624="" line625="        if (initalised == false) {" line626="            setup()" line627="        }" line628="" line629="        if (pinSelected == LfSensor.left) {" line630="            value2 = pins.analogReadPin(AnalogPin.P1)" line631="            ref = sensorLeftRef" line632="        }" line633="        else if (pinSelected == LfSensor.right) {" line634="            value2 = pins.analogReadPin(AnalogPin.P2)" line635="            ref = sensorRightRef" line636="        }" line637="" line638="        if (lightLevel == LightSelection.Light) {" line639="            if (value2 &gt;= (ref + detectionLevel)) {" line640="                result = true" line641="            }" line642="            else {" line643="                result = false" line644="            }" line645="        }" line646="        else if (lightLevel == LightSelection.Dark) {" line647="            if (value2 &lt;= (ref - detectionLevel)) {" line648="                result = true" line649="            }" line650="            else {" line651="                result = false" line652="            }" line653="        }" line654="        return result;" line655="    }" line656="" line657="    //////////////" line658="    //  MOTORS  //" line659="    //////////////" line660="" line661="    /**" line662="     * Sets the requested motor running in chosen direction at a set speed." line663="     * if the PCA has not yet been initialised calls the initialisation routine." line664="     * @param motor which motor to turn on" line665="     * @param dir   which direction to go" line666="     * @param speed how fast to spin the motor" line667="     */" line668="    //% subcategory=Motors" line669="    //% group=Motors" line670="    //% blockId=kitronik_move_motor_motor_on" line671="    //% block=&quot;turn %motor|motor on direction %dir|speed %speed&quot;" line672="    //% weight=100 blockGap=8" line673="    //% speed.min=0 speed.max=100" line674="    export function motorOn(motor: Motors, dir: MotorDirection, speed: number): void {" line675="        if (initalised == false) {" line676="            setup()" line677="        }" line678="" line679="        /*convert 0-100 to 0-250 (approx) We wont worry about the last 95 to make life simpler*/" line680="        let outputVal = Math.idiv(speed, MOTOR_DUTY_CYCLE_RATION)" line681="" line682="        let buf2 = pins.createBuffer(2)" line683="" line684="        switch (dir) {" line685="            case MotorDirection.Forward:" line686="                buf2[0] = motor" line687="                buf2[1] = outputVal" line688="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line689="                buf2[0] = motor + 1" line690="                buf2[1] = 0x00" line691="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line692="                break" line693="            case MotorDirection.Reverse:" line694="                buf2[0] = motor + 1" line695="                buf2[1] = outputVal" line696="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line697="                buf2[0] = motor" line698="                buf2[1] = 0x00" line699="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line700="                break" line701="        }" line702="    }" line703="" line704="    /**" line705="     * Turns off the specified motor." line706="     * @param motor which motor to turn off" line707="     */" line708="    //% subcategory=Motors" line709="    //% group=Motors" line710="    //% blockId=kitronik_move_motor_motor_off" line711="    //% weight=95 blockGap=8" line712="    //%block=&quot;turn off %motor| motor&quot;" line713="    export function motorOff(motor: Motors): void {" line714="        let buf3 = pins.createBuffer(2)" line715="        buf3[0] = motor" line716="        buf3[1] = 0x00" line717="        pins.i2cWriteBuffer(CHIP_ADDR, buf3, false)" line718="        buf3[0] = motor + 1" line719="        buf3[1] = 0x00" line720="        pins.i2cWriteBuffer(CHIP_ADDR, buf3, false)" line721="    }" line722="" line723="" line724="    //////////////" line725="    //  SOUNDS  //" line726="    //////////////" line727="" line728="    /**" line729="     * Turns on and off the horn." line730="     * @param hornTimes is the number of times to sound the horn" line731="     */" line732="    //% subcategory=Sounds" line733="    //% group=Sounds" line734="    //% blockId=kitronik_move_motor_horn" line735="    //% weight=95 blockGap=8" line736="    //% block=&quot;beep the horn %hornTimes&quot;" line737="    //% hornTimes.min = 1 hornTimes.max = 5 hornTimes.defl = 1" line738="    export function beepHorn(hornTimes: number): void {" line739="        for (let u = 0; u &lt;= hornTimes; u++) {" line740="            music.playTone(185, music.beat(BeatFraction.Quarter))" line741="            basic.pause(75)" line742="            music.playTone(185, music.beat(BeatFraction.Quarter))" line743="            basic.pause(75)" line744="        }" line745="    }" line746="" line747="    /**" line748="    * Turns on and off the horn." line749="    * @param siren is the selection to turn on or off the siren" line750="    */" line751="    //% subcategory=Sounds" line752="    //% group=Sounds" line753="    //% blockId=kitronik_move_motor_siren" line754="    //% weight=95 blockGap=8" line755="    //% block=&quot;turn siren %siren&quot;" line756="    export function soundSiren(siren: OnOffSelection): void {" line757="        if (siren == OnOffSelection.On) {" line758="            sirenOn = true" line759="            turnOnSiren()" line760="        }" line761="        else {" line762="            sirenOn = false" line763="        }" line764="    }" line765="" line766="    function turnOnSiren(): void {" line767="        control.inBackground(() =&gt; {" line768="            while (sirenOn) {" line769="                music.playTone(370, music.beat(BeatFraction.Half))" line770="                basic.pause(75)" line771="                music.playTone(262, music.beat(BeatFraction.Half))" line772="                basic.pause(75)" line773="            }" line774="" line775="        })" line776="    }"></mutation><comment id="undefined" w="160" h="80" pinned="false">% weight=100 color=#00A654 icon="\uf1b9" % block="Move Motor" % groups='["Lights", "Sensors", "Motors", "Sound"]'</comment><data>0</data></block></statement></block></xml>