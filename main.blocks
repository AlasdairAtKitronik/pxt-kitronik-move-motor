<xml xmlns="https://developers.google.com/blockly/xml"><comment id="_|NQ2_Beul,@[uV`r7o2" w="480" data="0" y="0" x="0" h="120">Blocks for driving the Kitronik MOVE Motor Board</comment><block id="O2l4sk_wt?;C9g094U+K" type="pxt-on-start" y="10" x="10"><statement name="HANDLER"><block id="6an2(AHOabNsPW!lWrM/" type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" numlines="755" line0="namespace Kitronik_Move_Motor {" line1="    //Constants " line2="    let CHIP_ADDR = 0xE0 // CHIP_ADDR is the standard chip address for the PCA9632" line3="    let MODE_1_REG_ADDR = 0x00 //mode 1 register address" line4="    let MODE_2_REG_ADDR = 0x01  //mode 2 register address" line5="    let LED_OUT_ADDR = 0x08  //LED output register address" line6="" line7="    let MODE_1_REG_VALUE = 0x00 //the prescale register address" line8="    let MODE_2_REG_VALUE = 0x10  //The mode 1 register address" line9="    let LED_OUT_VALUE = 0xAA  //The mode 1 register address" line10="" line11="    let MOTOR_DUTY_CYCLE_RATION = 0.4" line12="" line13="    /*GENERAL*/" line14="    export enum OnOffSelection {" line15="        //% block=&quot;on&quot;" line16="        On = 1," line17="        //% block=&quot;off&quot;" line18="        Off = 0" line19="    }" line20="" line21="    /* ZIPLEDS*/" line22="    //Well known colors for ZIP LEDs" line23="    enum ZipLedColors {" line24="        //% block=red" line25="        Red = 0xFF0000," line26="        //% block=orange" line27="        Orange = 0xFFA500," line28="        //% block=yellow" line29="        Yellow = 0xFFFF00," line30="        //% block=green" line31="        Green = 0x00FF00," line32="        //% block=blue" line33="        Blue = 0x0000FF," line34="        //% block=indigo" line35="        Indigo = 0x4b0082," line36="        //% block=violet" line37="        Violet = 0x8a2be2," line38="        //% block=purple" line39="        Purple = 0xFF00FF," line40="        //% block=white" line41="        White = 0xFFFFFF," line42="        //% block=black" line43="        Black = 0x000000" line44="    }" line45="" line46="    /*MOTORS*/" line47="    // List of motors for the motor blocks to use. These represent register offsets in the PCA9865 driver IC." line48="    export enum Motors {" line49="        //% block=&quot;Left&quot;" line50="        MotorLeft = 0x02," line51="        //% block=&quot;Right&quot;" line52="        MotorRight = 0x04" line53="    }" line54="    // Directions the motors can rotate." line55="    export enum MotorDirection {" line56="        //% block=&quot;Forward&quot;" line57="        Forward," line58="        //% block=&quot;Reverse&quot;" line59="        Reverse" line60="    }" line61="" line62="    /*ULTRASONIC*/" line63="    // Units for ultrasonic sensors to measure" line64="    export enum Units {" line65="        //% block=&quot;cm&quot;" line66="        Centimeters," line67="        //% block=&quot;inches&quot;" line68="        Inches" line69="    }" line70="" line71="    /*LINE FOLLOWING*/" line72="    // Selection of line following sensor" line73="    export enum LfSensor {" line74="        //% block=&quot;left&quot;" line75="        left," line76="        //% block=&quot;right&quot;" line77="        right" line78="    }" line79="    //Light level detection mode selection" line80="    export enum LightSelection {" line81="        //% block=&quot;Light&quot;" line82="        Light," line83="        //% block=&quot;Dark&quot;" line84="        Dark" line85="    }" line86="" line87="    let initalised = false //a flag to allow us to initialise without explicitly calling the secret incantation" line88="    //Motor global variables" line89="    let sirenOn = false" line90="    //Ultrasonic global variables" line91="    let triggerPin = DigitalPin.P13" line92="    let echoPin = DigitalPin.P14" line93="    //Line following sensors global variables" line94="    let sensorLeftRef = 0" line95="    let sensorRightRef = 0" line96="    let detectionLevel = 45&#9;&#9;//reading is done by converting 0.13V into ADC reading (3/1024)*45, this is the default setting" line97="" line98="" line99="&#9;/*" line100="&#9;&#9;This secret incantation sets up the PCA9632 I2C driver chip to be running " line101="    */" line102="    function setup(): void {" line103="        let buf = pins.createBuffer(2)" line104="" line105="        buf[0] = MODE_1_REG_ADDR" line106="        buf[1] = MODE_1_REG_VALUE" line107="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line108="        buf[0] = MODE_2_REG_ADDR" line109="        buf[1] = MODE_2_REG_VALUE" line110="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line111="        buf[0] = LED_OUT_ADDR" line112="        buf[1] = LED_OUT_VALUE" line113="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line114="" line115="        sensorLeftRef = pins.analogReadPin(AnalogPin.P1)" line116="        sensorRightRef = pins.analogReadPin(AnalogPin.P2)" line117="        initalised = true" line118="    }" line119="" line120="    //////////////" line121="    //  LIGHTS  //" line122="    //////////////" line123="" line124="    /**" line125="    * Turns on and off the horn." line126="    * @param motor which motor to turn off" line127="    */" line128="    //% group=Lights" line129="    //% blockId=kitronik_move_motor_tail_light" line130="    //% weight=95 blockGap=8" line131="    //% block=&quot;turn tail light %illuminate&quot;" line132="    export function shineTailLight(illuminate: OnOffSelection): void {" line133="        if (illuminate == OnOffSelection.On) {" line134="            pins.digitalWritePin(DigitalPin.P12, 1);" line135="        }" line136="        else {" line137="            pins.digitalWritePin(DigitalPin.P12, 0);" line138="        }" line139="    }" line140="" line141="    export class MoveMotorZIP {" line142="        buf: Buffer;" line143="        pin: DigitalPin;" line144="        brightness: number;" line145="        start: number;" line146="        _length: number;" line147="" line148="" line149="        /**" line150="         * Shows a rainbow pattern on all LEDs. " line151="         * @param startHue the start hue value for the rainbow, eg: 1" line152="         * @param endHue the end hue value for the rainbow, eg: 360" line153="         */" line154="        //% subcategory=&quot;ZIP LEDs&quot;" line155="        //% blockId=&quot;kitronik_move_motor_rainbow&quot; 7" line156="        //% block=&quot;%moveMotorZIP|show rainbow from %startHue|to %endHue&quot;" line157="        //% weight=94 blockGap=8" line158="        showRainbow(startHue: number = 1, endHue: number = 360) {" line159="            if (this._length &lt;= 0) return;" line160="" line161="            startHue = startHue &gt;&gt; 0;" line162="            endHue = endHue &gt;&gt; 0;" line163="            const saturation = 100;" line164="            const luminance = 50;" line165="            const steps = this._length;" line166="            const direction = HueInterpolationDirection.Clockwise;" line167="" line168="            //hue" line169="            const h1 = startHue;" line170="            const h2 = endHue;" line171="            const hDistCW = ((h2 + 360) - h1) % 360;" line172="            const hStepCW = Math.idiv((hDistCW * 100), steps);" line173="            const hDistCCW = ((h1 + 360) - h2) % 360;" line174="            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line175="            let hStep: number;" line176="            if (direction === HueInterpolationDirection.Clockwise) {" line177="                hStep = hStepCW;" line178="            } else if (direction === HueInterpolationDirection.CounterClockwise) {" line179="                hStep = hStepCCW;" line180="            } else {" line181="                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line182="            }" line183="            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line184="" line185="            //sat" line186="            const s1 = saturation;" line187="            const s2 = saturation;" line188="            const sDist = s2 - s1;" line189="            const sStep = Math.idiv(sDist, steps);" line190="            const s1_100 = s1 * 100;" line191="" line192="            //lum" line193="            const l1 = luminance;" line194="            const l2 = luminance;" line195="            const lDist = l2 - l1;" line196="            const lStep = Math.idiv(lDist, steps);" line197="            const l1_100 = l1 * 100" line198="" line199="            //interpolate" line200="            if (steps === 1) {" line201="                this.setPixelRGB(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line202="            } else {" line203="                this.setPixelRGB(0, hsl(startHue, saturation, luminance));" line204="                for (let i = 1; i &lt; steps - 1; i++) {" line205="                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;" line206="                    const s = Math.idiv((s1_100 + i * sStep), 100);" line207="                    const l = Math.idiv((l1_100 + i * lStep), 100);" line208="                    this.setPixelRGB(i, hsl(h, s, l));" line209="                }" line210="                this.setPixelRGB(steps - 1, hsl(endHue, saturation, luminance));" line211="            }" line212="            this.show();" line213="        }" line214="" line215="&#9;&#9;/**" line216="         * Displays a vertical bar graph based on the `value` and `high` value." line217="         * If `high` is 0, the chart gets adjusted automatically." line218="         * @param value current value to plot" line219="         * @param high maximum value, eg: 255" line220="         */" line221="        //% subcategory=&quot;ZIP LEDs&quot;" line222="        //% weight=84 blockGap=8" line223="        //% blockId=kitronik_move_motor_show_bar_graph " line224="        //% block=&quot;%moveMotorZIP|show bar graph of %value|up to %high&quot;" line225="        showBarGraph(value: number, high: number): void {" line226="            if (high &lt;= 0) {" line227="                this.clear();" line228="                this.setPixelRGB(0, 0xFFFF00);" line229="                this.show();" line230="                return;" line231="            }" line232="" line233="            value = Math.abs(value);" line234="            const n = this._length;" line235="            const n1 = n - 1;" line236="            let v = Math.idiv((value * n), high);" line237="            if (v == 0) {" line238="                this.setPixelRGB(0, 0x666600);" line239="                for (let j = 1; j &lt; n; ++j)" line240="                    this.setPixelRGB(j, 0);" line241="            } else {" line242="                for (let k = 0; k &lt; n; ++k) {" line243="                    if (k &lt;= v) {" line244="                        const g = Math.idiv(k * 255, n1);" line245="                        //this.setPixelRGB(i, moveMotorZIP.rgb(0, g, 255 - g));" line246="                        this.setPixelRGB(k, rgb(g, 255 - g, 0));" line247="                    }" line248="                    else this.setPixelRGB(k, 0);" line249="                }" line250="            }" line251="            this.show();" line252="        }" line253="" line254="        /** " line255="        * Create a range of LEDs." line256="        * @param start offset in the LED strip to start the range" line257="        * @param length number of LEDs in the range. eg: 4" line258="        */" line259="        //% subcategory=&quot;ZIP LEDs&quot;" line260="        //% weight=89 blockGap=8" line261="        //% blockId=&quot;kitronik_move_motor_range&quot; " line262="        //% block=&quot;%moveMotorZIP|range from %start|with %length|leds&quot;" line263="        range(start: number, length: number): MoveMotorZIP {" line264="            start = start &gt;&gt; 0;" line265="            length = length &gt;&gt; 0;" line266="            let moveMotorZIP = new MoveMotorZIP();" line267="            moveMotorZIP.buf = this.buf;" line268="            moveMotorZIP.pin = this.pin;" line269="            moveMotorZIP.brightness = this.brightness;" line270="            moveMotorZIP.start = this.start + Math.clamp(0, this._length - 1, start);" line271="            moveMotorZIP._length = Math.clamp(0, this._length - (moveMotorZIP.start - this.start), length);" line272="            return moveMotorZIP;" line273="        }" line274="" line275="        /**" line276="         * Rotate LEDs forward." line277="         * You need to call ``show`` to make the changes visible." line278="         * @param offset number of ZIP LEDs to rotate forward, eg: 1" line279="         */" line280="        //% subcategory=&quot;ZIP LEDs&quot;" line281="        //% blockId=&quot;kitronik_move_motor_display_rotate&quot; " line282="        //% block=&quot;%moveMotorZIP|rotate ZIP LEDs by %offset&quot; " line283="        //% weight=93 blockGap=8" line284="        rotate(offset: number = 1): void {" line285="            this.buf.rotate(-offset * 3, this.start * 3, this._length * 3)" line286="        }" line287="    &#9;/**" line288="         * Sets whole ZIP Halo display as a given color (range 0-255 for r, g, b). Call Show to make changes visible " line289="         * @param rgb RGB color of the LED" line290="         */" line291="        //% subcategory=&quot;ZIP LEDs&quot;" line292="        //% blockId=&quot;kitronik_move_motor_display_only_set_strip_color&quot; " line293="        //% block=&quot;%moveMotorZIP|set color %rgb=kitronik_move_motor_colors&quot;" line294="        //% weight=99 blockGap=8" line295="        setColor(rgb: number) {" line296="            rgb = rgb &gt;&gt; 0;" line297="            this.setAllRGB(rgb);" line298="        }" line299="    &#9;/**" line300="         * Shows whole ZIP Halo display as a given color (range 0-255 for r, g, b). " line301="         * @param rgb RGB color of the LED" line302="         */" line303="        //% subcategory=&quot;ZIP LEDs&quot;" line304="        //% blockId=&quot;kitronik_move_motor_display_set_strip_color&quot; " line305="        //% block=&quot;%moveMotorZIP|show color %rgb=kitronik_move_motor_colors&quot;" line306="        //% weight=99 blockGap=8" line307="        showColor(rgb: number) {" line308="            rgb = rgb &gt;&gt; 0;" line309="            this.setAllRGB(rgb);" line310="            this.show();" line311="        }" line312="" line313="        /**" line314="         * Set particular ZIP LED to a given color. " line315="         * You need to call ``show changes`` to make the changes visible." line316="         * @param zipLedNum position of the ZIP LED in the string" line317="         * @param rgb RGB color of the ZIP LED" line318="         */" line319="        //% subcategory=&quot;ZIP LEDs&quot;" line320="        //% blockId=&quot;kitronik_move_motor_set_zip_color&quot; " line321="        //% block=&quot;%moveMotorZIP|set ZIP LED %zipLedNum|to %rgb=kitronik_move_motor_colors&quot;" line322="        //% weight=98 blockGap=8" line323="        setZipLedColor(zipLedNum: number, rgb: number): void {" line324="            this.setPixelRGB(zipLedNum &gt;&gt; 0, rgb &gt;&gt; 0);" line325="        }" line326="" line327="        /**" line328="         * Send all the changes to the ZIP Halo display." line329="         */" line330="        //% subcategory=&quot;ZIP LEDs&quot;" line331="        //% blockId=&quot;kitronik_move_motor_display_show&quot; " line332="        //% block=&quot;%moveMotorZIP|show&quot; blockGap=8" line333="        //% weight=96" line334="        show() {" line335="            //use the Kitronik version which respects brightness for all " line336="            ws2812b.sendBuffer(this.buf, this.pin, this.brightness);" line337="        }" line338="" line339="        /**" line340="         * Turn off all LEDs on the ZIP Halo display." line341="         * You need to call ``show`` to make the changes visible." line342="         */" line343="        //% subcategory=&quot;ZIP LEDs&quot;" line344="        //% blockId=&quot;kitronik_move_motor_display_clear&quot;" line345="        //% block=&quot;%moveMotorZIP|clear&quot;" line346="        //% weight=95 blockGap=8" line347="        clear(): void {" line348="            this.buf.fill(0, this.start * 3, this._length * 3);" line349="        }" line350="" line351="        /**" line352="         * Set the brightness of the ZIP Halo display. This flag only applies to future show operation." line353="         * @param brightness a measure of LED brightness in 0-255. eg: 255" line354="         */" line355="        //% subcategory=&quot;ZIP LEDs&quot;" line356="        //% blockId=&quot;kitronik_move_motordisplay_set_brightness&quot;" line357="        //% block=&quot;%moveMotorZIP|set brightness %brightness&quot; " line358="        //% weight=92 blockGap=8" line359="        //% brightness.min=0 brightness.max=255" line360="        setBrightness(brightness: number): void {" line361="            //Clamp incoming variable at 0-255 as values out of this range cause unexpected brightnesses as the lower level code only expects a byte." line362="            if (brightness &lt; 0) {" line363="                brightness = 0" line364="            }" line365="            else if (brightness &gt; 255) {" line366="                brightness = 255" line367="            }" line368="            this.brightness = brightness &amp; 0xff;" line369="            basic.pause(1) //add a pause to stop wierdnesses" line370="        }" line371="" line372="        //Sets up the buffer for pushing LED control data out to LEDs" line373="        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {" line374="            this.buf[offset + 0] = green;" line375="            this.buf[offset + 1] = red;" line376="            this.buf[offset + 2] = blue;" line377="        }" line378="" line379="        //Separates out Red, Green and Blue data and fills the LED control data buffer for all LEDs" line380="        private setAllRGB(rgb: number) {" line381="            let red = unpackR(rgb);" line382="            let green = unpackG(rgb);" line383="            let blue = unpackB(rgb);" line384="" line385="            const end = this.start + this._length;" line386="            for (let m = this.start; m &lt; end; ++m) {" line387="                this.setBufferRGB(m * 3, red, green, blue)" line388="            }" line389="        }" line390="" line391="        //Separates out Red, Green and Blue data and fills the LED control data buffer for a single LED" line392="        private setPixelRGB(pixeloffset: number, rgb: number): void {" line393="            if (pixeloffset &lt; 0" line394="                || pixeloffset &gt;= this._length)" line395="                return;" line396="" line397="            pixeloffset = (pixeloffset + this.start) * 3;" line398="" line399="            let red2 = unpackR(rgb);" line400="            let green2 = unpackG(rgb);" line401="            let blue2 = unpackB(rgb);" line402="" line403="            this.setBufferRGB(pixeloffset, red2, green2, blue2)" line404="        }" line405="    }" line406="" line407="    /**" line408="     * Create a new ZIP LED driver for MOVE Motor board." line409="&#9; * @param numZips number of leds in the strip, eg: 4" line410="     */" line411="    //% subcategory=&quot;ZIP LEDs&quot;" line412="    //% blockId=&quot;kitronik_move_motor_ZIP_LED_create&quot; " line413="    //% block=&quot;to Halo HD with %numZips|ZIP LEDs&quot;" line414="    //% weight=100 blockGap=8" line415="    //% trackArgs=0,2" line416="    //% blockSetVariable=moveMotorZIP" line417="    export function createMoveMotorZIPLED(numZips: number): MoveMotorZIP {" line418="        let moveMotorZIP2 = new MoveMotorZIP();" line419="        moveMotorZIP2.buf = pins.createBuffer(numZips * 3);" line420="        moveMotorZIP2.start = 0;" line421="        moveMotorZIP2._length = numZips;" line422="        moveMotorZIP2.setBrightness(128)" line423="        moveMotorZIP2.pin = DigitalPin.P8;" line424="        pins.digitalWritePin(moveMotorZIP2.pin, 8);" line425="        return moveMotorZIP2;" line426="    }" line427="" line428="    /*  The LEDs we are using have centre wavelengths of 470nm (Blue) 525nm(Green) and 625nm (Red) " line429="    * &#9; We blend these linearly to give the impression of the other wavelengths. " line430="    *   as we cant wavelength shift an actual LED... (Ye canna change the laws of physics Capt)*/" line431="" line432="    /**" line433="     * Converts value to red, green, blue channels" line434="     * @param red value of the red channel between 0 and 255. eg: 255" line435="     * @param green value of the green channel between 0 and 255. eg: 255" line436="     * @param blue value of the blue channel between 0 and 255. eg: 255" line437="     */" line438="    //% subcategory=&quot;ZIP LEDs&quot;" line439="    //% weight=1 blockGap=8" line440="    //% blockId=&quot;kitronik_move_motor_rgb&quot; block=&quot;red %red|green %green|blue %blue&quot;" line441="    export function rgb(red: number, green: number, blue: number): number {" line442="        return packRGB(red, green, blue);" line443="    }" line444="" line445="    /**" line446="     * Gets the RGB value of a known color" line447="    */" line448="    //% subcategory=&quot;ZIP LEDs&quot;" line449="    //% weight=2 blockGap=8" line450="    //% blockId=&quot;kitronik_move_motor_colors&quot; block=&quot;%color&quot;" line451="    export function colors(color: ZipLedColors): number {" line452="        return color;" line453="    }" line454="" line455="    //Combines individual RGB settings to be a single number" line456="    function packRGB(a: number, b: number, c: number): number {" line457="        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);" line458="    }" line459="    //Separates red value from combined number" line460="    function unpackR(rgb: number): number {" line461="        let r = (rgb &gt;&gt; 16) &amp; 0xFF;" line462="        return r;" line463="    }" line464="    //Separates green value from combined number" line465="    function unpackG(rgb: number): number {" line466="        let o = (rgb &gt;&gt; 8) &amp; 0xFF;" line467="        return o;" line468="    }" line469="    //Separates blue value from combined number" line470="    function unpackB(rgb: number): number {" line471="        let b = (rgb) &amp; 0xFF;" line472="        return b;" line473="    }" line474="" line475="    /**" line476="     * Converts a hue saturation luminosity value into a RGB color" line477="     */" line478="    function hsl(h: number, s: number, l: number): number {" line479="        h = Math.round(h);" line480="        s = Math.round(s);" line481="        l = Math.round(l);" line482="" line483="        h = h % 360;" line484="        s = Math.clamp(0, 99, s);" line485="        l = Math.clamp(0, 99, l);" line486="        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line487="        let h12 = Math.idiv(h, 60);//[0,6]" line488="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line489="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line490="        let x = (c * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line491="        let r$: number;" line492="        let g$: number;" line493="        let b$: number;" line494="        if (h12 == 0) {" line495="            r$ = c; g$ = x; b$ = 0;" line496="        } else if (h12 == 1) {" line497="            r$ = x; g$ = c; b$ = 0;" line498="        } else if (h12 == 2) {" line499="            r$ = 0; g$ = c; b$ = x;" line500="        } else if (h12 == 3) {" line501="            r$ = 0; g$ = x; b$ = c;" line502="        } else if (h12 == 4) {" line503="            r$ = x; g$ = 0; b$ = c;" line504="        } else if (h12 == 5) {" line505="            r$ = c; g$ = 0; b$ = x;" line506="        }" line507="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c), 2);" line508="        let t = r$ + p;" line509="        let q = g$ + p;" line510="        let d = b$ + p;" line511="        return packRGB(t, q, d);" line512="    }" line513="" line514="    /**" line515="     * Options for direction hue changes, used by rainbow block (never visible to end user)" line516="     */" line517="    export enum HueInterpolationDirection {" line518="        Clockwise," line519="        CounterClockwise," line520="        Shortest" line521="    }" line522="" line523="    //////////////" line524="    //  SENSORS //" line525="    //////////////" line526="    /**" line527="     * Measure the echo time (after trigger) and converts to cm or inches and returns as an int" line528="     * @param unit desired conversion unit" line529="     * @param maxCmDistance maximum distance in centimeters (default is 500)" line530="     */" line531="    //% blockId=kitronik_move_motor_ultrasonic_measure" line532="    //% block=&quot;measure distances in |unit %unit&quot;" line533="    export function measure(unit: Units, maxCmDistance = 500): number {" line534="        // send pulse" line535="        pins.setPull(triggerPin, PinPullMode.PullNone);" line536="        pins.digitalWritePin(triggerPin, 0);" line537="        control.waitMicros(2);" line538="        pins.digitalWritePin(triggerPin, 1);" line539="        control.waitMicros(10);" line540="        pins.digitalWritePin(triggerPin, 0);" line541="" line542="        // read pulse" line543="        const pulse = pins.pulseIn(echoPin, PulseValue.High, maxCmDistance * 39);" line544="        switch (unit) {" line545="            case Units.Centimeters: return Math.idiv(pulse, 39);" line546="            case Units.Inches: return Math.idiv(pulse, 98);" line547="            default: return 0;" line548="        }" line549="    }" line550="" line551="" line552="    /**" line553="    * Set sensor threshold block allows the user to adjust the point at which the sensor detects" line554="    * @param level is the threshold percentage" line555="    */" line556="    //% blockId=kitronik_move_motor_line_follower_set_threshold" line557="    //% block=&quot;set sensor threshold to %level|&quot;" line558="    //% level.min=0 level.max=100 level.defl=50" line559="    //% weight=85 blockGap=8" line560="    export function setSensorDetectionLevel(level: number) {" line561="        if (initalised == false) {" line562="            setup()" line563="        }" line564="        detectionLevel = (level / 2) + 10" line565="    }" line566="" line567="    /**" line568="    * Read sensor block allows user to read the value of the sensor (returns value in range 0-1023)" line569="    * @param pinSelected is the selection of pin to read a particular sensor" line570="    */" line571="    //% blockId=kitronik_move_motor_line_follower_read_sensor" line572="    //% block=&quot;read sensor on pin %pinSelected&quot;" line573="    //% weight=90 blockGap=8" line574="    export function readSensor(sensorSelected: LfSensor) {" line575="        let value = 0" line576="" line577="        if (initalised == false) {" line578="            setup()" line579="        }" line580="" line581="        if (sensorSelected == LfSensor.left) {" line582="            value = pins.analogReadPin(AnalogPin.P1)" line583="        }" line584="        else if (sensorSelected == LfSensor.right) {" line585="            value = pins.analogReadPin(AnalogPin.P1)" line586="        }" line587="        return value;" line588="    }" line589="" line590="    /**" line591="    * Sensor on pin detection returns a true or false when the sensor has detected" line592="    * @param pinSelected is the selection of pin to read a particular sensor" line593="&#9;* @param lightSelection is the selection of the sensor detecting light or dark" line594="    */" line595="    //% blockId=kitronik_move_motor_line_follower_digital_sensor" line596="    //% block=&quot;sensor on pin %pinSelected| detected %LightSelection&quot;" line597="    //% weight=95 blockGap=8" line598="    export function sensorDigitalDetection(pinSelected: LfSensor, lightLevel: LightSelection): boolean {" line599="        let value2 = 0" line600="        let ref = 0" line601="        let result = false" line602="" line603="        if (initalised == false) {" line604="            setup()" line605="        }" line606="" line607="        if (pinSelected == LfSensor.left) {" line608="            value2 = pins.analogReadPin(AnalogPin.P1)" line609="            ref = sensorLeftRef" line610="        }" line611="        else if (pinSelected == LfSensor.right) {" line612="            value2 = pins.analogReadPin(AnalogPin.P2)" line613="            ref = sensorRightRef" line614="        }" line615="" line616="        if (lightLevel == LightSelection.Light) {" line617="            if (value2 &gt;= (ref + detectionLevel)) {" line618="                result = true" line619="            }" line620="            else {" line621="                result = false" line622="            }" line623="        }" line624="        else if (lightLevel == LightSelection.Dark) {" line625="            if (value2 &lt;= (ref - detectionLevel)) {" line626="                result = true" line627="            }" line628="            else {" line629="                result = false" line630="            }" line631="        }" line632="        return result;" line633="    }" line634="" line635="    //////////////" line636="    //  MOTORS  //" line637="    //////////////" line638="" line639="    /**" line640="     * Sets the requested motor running in chosen direction at a set speed." line641="     * if the PCA has not yet been initialised calls the initialisation routine." line642="     * @param motor which motor to turn on" line643="     * @param dir   which direction to go" line644="     * @param speed how fast to spin the motor" line645="     */" line646="    //% subcategory=Motors" line647="    //% group=Motors" line648="    //% blockId=kitronik_move_motor_motor_on" line649="    //% block=&quot;turn %motor|motor on direction %dir|speed %speed&quot;" line650="    //% weight=100 blockGap=8" line651="    //% speed.min=0 speed.max=100" line652="    export function motorOn(motor: Motors, dir: MotorDirection, speed: number): void {" line653="        if (initalised == false) {" line654="            setup()" line655="        }" line656="" line657="        /*convert 0-100 to 0-250 (approx) We wont worry about the last 95 to make life simpler*/" line658="        let outputVal = Math.idiv(speed, MOTOR_DUTY_CYCLE_RATION)" line659="" line660="        let buf2 = pins.createBuffer(2)" line661="" line662="        switch (dir) {" line663="            case MotorDirection.Forward:" line664="                buf2[0] = motor" line665="                buf2[1] = outputVal" line666="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line667="                buf2[0] = motor + 1" line668="                buf2[1] = 0x00" line669="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line670="                break" line671="            case MotorDirection.Reverse:" line672="                buf2[0] = motor + 1" line673="                buf2[1] = outputVal" line674="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line675="                buf2[0] = motor" line676="                buf2[1] = 0x00" line677="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line678="                break" line679="        }" line680="    }" line681="" line682="    /**" line683="     * Turns off the specified motor." line684="     * @param motor which motor to turn off" line685="     */" line686="    //% subcategory=Motors" line687="    //% group=Motors" line688="    //% blockId=kitronik_move_motor_motor_off" line689="    //% weight=95 blockGap=8" line690="    //%block=&quot;turn off %motor| motor&quot;" line691="    export function motorOff(motor: Motors): void {" line692="        let buf3 = pins.createBuffer(2)" line693="        buf3[0] = motor" line694="        buf3[1] = 0x00" line695="        pins.i2cWriteBuffer(CHIP_ADDR, buf3, false)" line696="        buf3[0] = motor + 1" line697="        buf3[1] = 0x00" line698="        pins.i2cWriteBuffer(CHIP_ADDR, buf3, false)" line699="    }" line700="" line701="" line702="    //////////////" line703="    //  SOUNDS  //" line704="    //////////////" line705="" line706="    /**" line707="     * Turns on and off the horn." line708="     * @param motor which motor to turn off" line709="     */" line710="    //% group=Sounds" line711="    //% blockId=kitronik_move_motor_horn" line712="    //% weight=95 blockGap=8" line713="    //%block=&quot;beep the horn %hornTimes&quot;" line714="    //% hornTimes.min = 1 hornTimes.max = 5 hornTimes.defl = 1" line715="    export function beepHorn(hornTimes: number): void {" line716="        for (let u = 0; u &lt;= hornTimes; u++) {" line717="            music.playTone(185, music.beat(BeatFraction.Quarter))" line718="            basic.pause(75)" line719="            music.playTone(185, music.beat(BeatFraction.Quarter))" line720="            basic.pause(75)" line721="        }" line722="    }" line723="" line724="    /**" line725="    * Turns on and off the horn." line726="    * @param motor which motor to turn off" line727="    */" line728="    //% group=Sounds" line729="    //% blockId=kitronik_move_motor_siren" line730="    //% weight=95 blockGap=8" line731="    //% block=&quot;turn siren %siren&quot;" line732="    export function soundSiren(siren: OnOffSelection): void {" line733="        if (siren == OnOffSelection.On) {" line734="            sirenOn = true" line735="            turnOnSiren()" line736="        }" line737="        else {" line738="            sirenOn = false" line739="        }" line740="    }" line741="" line742="    function turnOnSiren(): void {" line743="        control.inBackground(() =&gt; {" line744="            while (sirenOn) {" line745="                music.playTone(370, music.beat(BeatFraction.Half))" line746="                basic.pause(75)" line747="                music.playTone(262, music.beat(BeatFraction.Half))" line748="                basic.pause(75)" line749="            }" line750="" line751="        })" line752="    }" line753="" line754="}"></mutation><comment id="undefined" w="160" h="80" pinned="false">% weight=100 color=#00A654 icon="\uf1b9" block="Move Motor" % groups='["Lights", "Sensors", "Motors", "Sound"]'</comment><data>0</data></block></statement></block></xml>