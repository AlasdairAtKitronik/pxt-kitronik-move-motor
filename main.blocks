<xml xmlns="https://developers.google.com/blockly/xml"><comment id="_|NQ2_Beul,@[uV`r7o2" h="120" x="0" y="0" data="0" w="480">Blocks for driving the Kitronik MOVE Motor Board</comment><block id="O2l4sk_wt?;C9g094U+K" type="pxt-on-start" x="10" y="10"><statement name="HANDLER"><block id="6an2(AHOabNsPW!lWrM/" type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line754="}" line753="" line752="    }" line751="        })" line750="" line749="            }" line748="                basic.pause(75)" line747="                music.playTone(262, music.beat(BeatFraction.Half))" line746="                basic.pause(75)" line745="                music.playTone(370, music.beat(BeatFraction.Half))" line744="            while (sirenOn) {" line743="        control.inBackground(() =&gt; {" line742="    function turnOnSiren(): void {" line741="" line740="    }" line739="        }" line738="            sirenOn = false" line737="        else {" line736="        }" line735="            turnOnSiren()" line734="            sirenOn = true" line733="        if (siren == OnOffSelection.On) {" line732="    export function soundSiren(siren: OnOffSelection): void {" line731="    //% block=&quot;turn siren %siren&quot;" line730="    //% weight=95 blockGap=8" line729="    //% blockId=kitronik_move_motor_siren" line728="    //% group=Sounds" line727="    */" line726="    * @param motor which motor to turn off" line725="    * Turns on and off the horn." line724="    /**" line723="" line722="    }" line721="        }" line720="            basic.pause(75)" line719="            music.playTone(185, music.beat(BeatFraction.Quarter))" line718="            basic.pause(75)" line717="            music.playTone(185, music.beat(BeatFraction.Quarter))" line716="        for (let u = 0; u &lt;= hornTimes; u++) {" line715="    export function beepHorn(hornTimes: number): void {" line714="    //% hornTimes.min = 1 hornTimes.max = 5 hornTimes.defl = 1" line713="    //%block=&quot;beep the horn %hornTimes&quot;" line712="    //% weight=95 blockGap=8" line711="    //% blockId=kitronik_move_motor_horn" line710="    //% group=Sounds" line709="     */" line708="     * @param motor which motor to turn off" line707="     * Turns on and off the horn." line706="    /**" line705="" line704="    //////////////" line703="    //  SOUNDS  //" line702="    //////////////" line701="" line700="" line699="    }" line698="        pins.i2cWriteBuffer(CHIP_ADDR, buf3, false)" line697="        buf3[1] = 0x00" line696="        buf3[0] = motor + 1" line695="        pins.i2cWriteBuffer(CHIP_ADDR, buf3, false)" line694="        buf3[1] = 0x00" line693="        buf3[0] = motor" line692="        let buf3 = pins.createBuffer(2)" line691="    export function motorOff(motor: Motors): void {" line690="    //%block=&quot;turn off %motor| motor&quot;" line689="    //% weight=95 blockGap=8" line688="    //% blockId=kitronik_move_motor_motor_off" line687="    //% group=Motors" line686="    //% subcategory=Motors" line685="     */" line684="     * @param motor which motor to turn off" line683="     * Turns off the specified motor." line682="    /**" line681="" line680="    }" line679="        }" line678="                break" line677="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line676="                buf2[1] = 0x00" line675="                buf2[0] = motor" line674="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line673="                buf2[1] = outputVal" line672="                buf2[0] = motor + 1" line671="            case MotorDirection.Reverse:" line670="                break" line669="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line668="                buf2[1] = 0x00" line667="                buf2[0] = motor + 1" line666="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line665="                buf2[1] = outputVal" line664="                buf2[0] = motor" line663="            case MotorDirection.Forward:" line662="        switch (dir) {" line661="" line660="        let buf2 = pins.createBuffer(2)" line659="" line658="        let outputVal = Math.idiv(speed, MOTOR_DUTY_CYCLE_RATION)" line657="        /*convert 0-100 to 0-250 (approx) We wont worry about the last 95 to make life simpler*/" line656="" line655="        }" line654="            setup()" line653="        if (initalised == false) {" line652="    export function motorOn(motor: Motors, dir: MotorDirection, speed: number): void {" line651="    //% speed.min=0 speed.max=100" line650="    //% weight=100 blockGap=8" line649="    //% block=&quot;turn %motor|motor on direction %dir|speed %speed&quot;" line648="    //% blockId=kitronik_move_motor_motor_on" line647="    //% group=Motors" line646="    //% subcategory=Motors" line645="     */" line644="     * @param speed how fast to spin the motor" line643="     * @param dir   which direction to go" line642="     * @param motor which motor to turn on" line641="     * if the PCA has not yet been initialised calls the initialisation routine." line640="     * Sets the requested motor running in chosen direction at a set speed." line639="    /**" line638="" line637="    //////////////" line636="    //  MOTORS  //" line635="    //////////////" line634="" line633="    }" line632="        return result;" line631="        }" line630="            }" line629="                result = false" line628="            else {" line627="            }" line626="                result = true" line625="            if (value2 &lt;= (ref - detectionLevel)) {" line624="        else if (lightLevel == LightSelection.Dark) {" line623="        }" line622="            }" line621="                result = false" line620="            else {" line619="            }" line618="                result = true" line617="            if (value2 &gt;= (ref + detectionLevel)) {" line616="        if (lightLevel == LightSelection.Light) {" line615="" line614="        }" line613="            ref = sensorRightRef" line612="            value2 = pins.analogReadPin(AnalogPin.P2)" line611="        else if (pinSelected == LfSensor.right) {" line610="        }" line609="            ref = sensorLeftRef" line608="            value2 = pins.analogReadPin(AnalogPin.P1)" line607="        if (pinSelected == LfSensor.left) {" line606="" line605="        }" line604="            setup()" line603="        if (initalised == false) {" line602="" line601="        let result = false" line600="        let ref = 0" line599="        let value2 = 0" line598="    export function sensorDigitalDetection(pinSelected: LfSensor, lightLevel: LightSelection): boolean {" line597="    //% weight=95 blockGap=8" line596="    //% block=&quot;sensor on pin %pinSelected| detected %LightSelection&quot;" line595="    //% blockId=kitronik_move_motor_line_follower_digital_sensor" line594="    */" line593="&#9;* @param lightSelection is the selection of the sensor detecting light or dark" line592="    * @param pinSelected is the selection of pin to read a particular sensor" line591="    * Sensor on pin detection returns a true or false when the sensor has detected" line590="    /**" line589="" line588="    }" line587="        return value;" line586="        }" line585="            value = pins.analogReadPin(AnalogPin.P1)" line584="        else if (sensorSelected == LfSensor.right) {" line583="        }" line582="            value = pins.analogReadPin(AnalogPin.P1)" line581="        if (sensorSelected == LfSensor.left) {" line580="" line579="        }" line578="            setup()" line577="        if (initalised == false) {" line576="" line575="        let value = 0" line574="    export function readSensor(sensorSelected: LfSensor) {" line573="    //% weight=90 blockGap=8" line572="    //% block=&quot;read sensor on pin %pinSelected&quot;" line571="    //% blockId=kitronik_move_motor_line_follower_read_sensor" line570="    */" line569="    * @param pinSelected is the selection of pin to read a particular sensor" line568="    * Read sensor block allows user to read the value of the sensor (returns value in range 0-1023)" line567="    /**" line566="" line565="    }" line564="        detectionLevel = (level / 2) + 10" line563="        }" line562="            setup()" line561="        if (initalised == false) {" line560="    export function setSensorDetectionLevel(level: number) {" line559="    //% weight=85 blockGap=8" line558="    //% level.min=0 level.max=100 level.defl=50" line557="    //% block=&quot;set sensor threshold to %level|&quot;" line556="    //% blockId=kitronik_move_motor_line_follower_set_threshold" line555="    */" line554="    * @param level is the threshold percentage" line553="    * Set sensor threshold block allows the user to adjust the point at which the sensor detects" line552="    /**" line551="" line550="" line549="    }" line548="        }" line547="            default: return 0;" line546="            case Units.Inches: return Math.idiv(pulse, 98);" line545="            case Units.Centimeters: return Math.idiv(pulse, 39);" line544="        switch (unit) {" line543="        const pulse = pins.pulseIn(echoPin, PulseValue.High, maxCmDistance * 39);" line542="        // read pulse" line541="" line540="        pins.digitalWritePin(triggerPin, 0);" line539="        control.waitMicros(10);" line538="        pins.digitalWritePin(triggerPin, 1);" line537="        control.waitMicros(2);" line536="        pins.digitalWritePin(triggerPin, 0);" line535="        pins.setPull(triggerPin, PinPullMode.PullNone);" line534="        // send pulse" line533="    export function measure(unit: Units, maxCmDistance = 500): number {" line532="    //% block=&quot;measure distances in |unit %unit&quot;" line531="    //% blockId=kitronik_move_motor_ultrasonic_measure" line530="     */" line529="     * @param maxCmDistance maximum distance in centimeters (default is 500)" line528="     * @param unit desired conversion unit" line527="     * Measure the echo time (after trigger) and converts to cm or inches and returns as an int" line526="    /**" line525="    //////////////" line524="    //  SENSORS //" line523="    //////////////" line522="" line521="    }" line520="        Shortest" line519="        CounterClockwise," line518="        Clockwise," line517="    export enum HueInterpolationDirection {" line516="     */" line515="     * Options for direction hue changes, used by rainbow block (never visible to end user)" line514="    /**" line513="" line512="    }" line511="        return packRGB(t, q, d);" line510="        let d = b$ + p;" line509="        let q = g$ + p;" line508="        let t = r$ + p;" line507="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c), 2);" line506="        }" line505="            r$ = c; g$ = 0; b$ = x;" line504="        } else if (h12 == 5) {" line503="            r$ = x; g$ = 0; b$ = c;" line502="        } else if (h12 == 4) {" line501="            r$ = 0; g$ = x; b$ = c;" line500="        } else if (h12 == 3) {" line499="            r$ = 0; g$ = c; b$ = x;" line498="        } else if (h12 == 2) {" line497="            r$ = x; g$ = c; b$ = 0;" line496="        } else if (h12 == 1) {" line495="            r$ = c; g$ = x; b$ = 0;" line494="        if (h12 == 0) {" line493="        let b$: number;" line492="        let g$: number;" line491="        let r$: number;" line490="        let x = (c * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line489="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line488="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line487="        let h12 = Math.idiv(h, 60);//[0,6]" line486="        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line485="        l = Math.clamp(0, 99, l);" line484="        s = Math.clamp(0, 99, s);" line483="        h = h % 360;" line482="" line481="        l = Math.round(l);" line480="        s = Math.round(s);" line479="        h = Math.round(h);" line478="    function hsl(h: number, s: number, l: number): number {" line477="     */" line476="     * Converts a hue saturation luminosity value into a RGB color" line475="    /**" line474="" line473="    }" line472="        return b;" line471="        let b = (rgb) &amp; 0xFF;" line470="    function unpackB(rgb: number): number {" line469="    //Separates blue value from combined number" line468="    }" line467="        return o;" line466="        let o = (rgb &gt;&gt; 8) &amp; 0xFF;" line465="    function unpackG(rgb: number): number {" line464="    //Separates green value from combined number" line463="    }" line462="        return r;" line461="        let r = (rgb &gt;&gt; 16) &amp; 0xFF;" line460="    function unpackR(rgb: number): number {" line459="    //Separates red value from combined number" line458="    }" line457="        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);" line456="    function packRGB(a: number, b: number, c: number): number {" line455="    //Combines individual RGB settings to be a single number" line454="" line453="    }" line452="        return color;" line451="    export function colors(color: ZipLedColors): number {" line450="    //% blockId=&quot;kitronik_move_motor_colors&quot; block=&quot;%color&quot;" line449="    //% weight=2 blockGap=8" line448="    //% subcategory=&quot;ZIP LEDs&quot;" line447="    */" line446="     * Gets the RGB value of a known color" line445="    /**" line444="" line443="    }" line442="        return packRGB(red, green, blue);" line441="    export function rgb(red: number, green: number, blue: number): number {" line440="    //% blockId=&quot;kitronik_move_motor_rgb&quot; block=&quot;red %red|green %green|blue %blue&quot;" line439="    //% weight=1 blockGap=8" line438="    //% subcategory=&quot;ZIP LEDs&quot;" line437="     */" line436="     * @param blue value of the blue channel between 0 and 255. eg: 255" line435="     * @param green value of the green channel between 0 and 255. eg: 255" line434="     * @param red value of the red channel between 0 and 255. eg: 255" line433="     * Converts value to red, green, blue channels" line432="    /**" line431="" line430="    *   as we cant wavelength shift an actual LED... (Ye canna change the laws of physics Capt)*/" line429="    * &#9; We blend these linearly to give the impression of the other wavelengths. " line428="    /*  The LEDs we are using have centre wavelengths of 470nm (Blue) 525nm(Green) and 625nm (Red) " line427="" line426="    }" line425="        return moveMotorZIP2;" line424="        pins.digitalWritePin(moveMotorZIP2.pin, 8);" line423="        moveMotorZIP2.pin = DigitalPin.P8;" line422="        moveMotorZIP2.setBrightness(128)" line421="        moveMotorZIP2._length = numZips;" line420="        moveMotorZIP2.start = 0;" line419="        moveMotorZIP2.buf = pins.createBuffer(numZips * 3);" line418="        let moveMotorZIP2 = new MoveMotorZIP();" line417="    export function createMoveMotorZIPLED(numZips: number): MoveMotorZIP {" line416="    //% blockSetVariable=moveMotorZIP" line415="    //% trackArgs=0,2" line414="    //% weight=100 blockGap=8" line413="    //% block=&quot;to Halo HD with %numZips|ZIP LEDs&quot;" line412="    //% blockId=&quot;kitronik_move_motor_ZIP_LED_create&quot; " line411="    //% subcategory=&quot;ZIP LEDs&quot;" line410="     */" line409="&#9; * @param numZips number of leds in the strip, eg: 4" line408="     * Create a new ZIP LED driver for MOVE Motor board." line407="    /**" line406="" line405="    }" line404="        }" line403="            this.setBufferRGB(pixeloffset, red2, green2, blue2)" line402="" line401="            let blue2 = unpackB(rgb);" line400="            let green2 = unpackG(rgb);" line399="            let red2 = unpackR(rgb);" line398="" line397="            pixeloffset = (pixeloffset + this.start) * 3;" line396="" line395="                return;" line394="                || pixeloffset &gt;= this._length)" line393="            if (pixeloffset &lt; 0" line392="        private setPixelRGB(pixeloffset: number, rgb: number): void {" line391="        //Separates out Red, Green and Blue data and fills the LED control data buffer for a single LED" line390="" line389="        }" line388="            }" line387="                this.setBufferRGB(m * 3, red, green, blue)" line386="            for (let m = this.start; m &lt; end; ++m) {" line385="            const end = this.start + this._length;" line384="" line383="            let blue = unpackB(rgb);" line382="            let green = unpackG(rgb);" line381="            let red = unpackR(rgb);" line380="        private setAllRGB(rgb: number) {" line379="        //Separates out Red, Green and Blue data and fills the LED control data buffer for all LEDs" line378="" line377="        }" line376="            this.buf[offset + 2] = blue;" line375="            this.buf[offset + 1] = red;" line374="            this.buf[offset + 0] = green;" line373="        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {" line372="        //Sets up the buffer for pushing LED control data out to LEDs" line371="" line370="        }" line369="            basic.pause(1) //add a pause to stop wierdnesses" line368="            this.brightness = brightness &amp; 0xff;" line367="            }" line366="                brightness = 255" line365="            else if (brightness &gt; 255) {" line364="            }" line363="                brightness = 0" line362="            if (brightness &lt; 0) {" line361="            //Clamp incoming variable at 0-255 as values out of this range cause unexpected brightnesses as the lower level code only expects a byte." line360="        setBrightness(brightness: number): void {" line359="        //% brightness.min=0 brightness.max=255" line358="        //% weight=92 blockGap=8" line357="        //% block=&quot;%moveMotorZIP|set brightness %brightness&quot; " line356="        //% blockId=&quot;kitronik_move_motordisplay_set_brightness&quot;" line355="        //% subcategory=&quot;ZIP LEDs&quot;" line354="         */" line353="         * @param brightness a measure of LED brightness in 0-255. eg: 255" line352="         * Set the brightness of the ZIP Halo display. This flag only applies to future show operation." line351="        /**" line350="" line349="        }" line348="            this.buf.fill(0, this.start * 3, this._length * 3);" line347="        clear(): void {" line346="        //% weight=95 blockGap=8" line345="        //% block=&quot;%moveMotorZIP|clear&quot;" line344="        //% blockId=&quot;kitronik_move_motor_display_clear&quot;" line343="        //% subcategory=&quot;ZIP LEDs&quot;" line342="         */" line341="         * You need to call ``show`` to make the changes visible." line340="         * Turn off all LEDs on the ZIP Halo display." line339="        /**" line338="" line337="        }" line336="            ws2812b.sendBuffer(this.buf, this.pin, this.brightness);" line335="            //use the Kitronik version which respects brightness for all " line334="        show() {" line333="        //% weight=96" line332="        //% block=&quot;%moveMotorZIP|show&quot; blockGap=8" line331="        //% blockId=&quot;kitronik_move_motor_display_show&quot; " line330="        //% subcategory=&quot;ZIP LEDs&quot;" line329="         */" line328="         * Send all the changes to the ZIP Halo display." line327="        /**" line326="" line325="        }" line324="            this.setPixelRGB(zipLedNum &gt;&gt; 0, rgb &gt;&gt; 0);" line323="        setZipLedColor(zipLedNum: number, rgb: number): void {" line322="        //% weight=98 blockGap=8" line321="        //% block=&quot;%moveMotorZIP|set ZIP LED %zipLedNum|to %rgb=kitronik_move_motor_colors&quot;" line320="        //% blockId=&quot;kitronik_move_motor_set_zip_color&quot; " line319="        //% subcategory=&quot;ZIP LEDs&quot;" line318="         */" line317="         * @param rgb RGB color of the ZIP LED" line316="         * @param zipLedNum position of the ZIP LED in the string" line315="         * You need to call ``show changes`` to make the changes visible." line314="         * Set particular ZIP LED to a given color. " line313="        /**" line312="" line311="        }" line310="            this.show();" line309="            this.setAllRGB(rgb);" line308="            rgb = rgb &gt;&gt; 0;" line307="        showColor(rgb: number) {" line306="        //% weight=99 blockGap=8" line305="        //% block=&quot;%moveMotorZIP|show color %rgb=kitronik_move_motor_colors&quot;" line304="        //% blockId=&quot;kitronik_move_motor_display_set_strip_color&quot; " line303="        //% subcategory=&quot;ZIP LEDs&quot;" line302="         */" line301="         * @param rgb RGB color of the LED" line300="         * Shows whole ZIP Halo display as a given color (range 0-255 for r, g, b). " line299="    &#9;/**" line298="        }" line297="            this.setAllRGB(rgb);" line296="            rgb = rgb &gt;&gt; 0;" line295="        setColor(rgb: number) {" line294="        //% weight=99 blockGap=8" line293="        //% block=&quot;%moveMotorZIP|set color %rgb=kitronik_move_motor_colors&quot;" line292="        //% blockId=&quot;kitronik_move_motor_display_only_set_strip_color&quot; " line291="        //% subcategory=&quot;ZIP LEDs&quot;" line290="         */" line289="         * @param rgb RGB color of the LED" line288="         * Sets whole ZIP Halo display as a given color (range 0-255 for r, g, b). Call Show to make changes visible " line287="    &#9;/**" line286="        }" line285="            this.buf.rotate(-offset * 3, this.start * 3, this._length * 3)" line284="        rotate(offset: number = 1): void {" line283="        //% weight=93 blockGap=8" line282="        //% block=&quot;%moveMotorZIP|rotate ZIP LEDs by %offset&quot; " line281="        //% blockId=&quot;kitronik_move_motor_display_rotate&quot; " line280="        //% subcategory=&quot;ZIP LEDs&quot;" line279="         */" line278="         * @param offset number of ZIP LEDs to rotate forward, eg: 1" line277="         * You need to call ``show`` to make the changes visible." line276="         * Rotate LEDs forward." line275="        /**" line274="" line273="        }" line272="            return moveMotorZIP;" line271="            moveMotorZIP._length = Math.clamp(0, this._length - (moveMotorZIP.start - this.start), length);" line270="            moveMotorZIP.start = this.start + Math.clamp(0, this._length - 1, start);" line269="            moveMotorZIP.brightness = this.brightness;" line268="            moveMotorZIP.pin = this.pin;" line267="            moveMotorZIP.buf = this.buf;" line266="            let moveMotorZIP = new MoveMotorZIP();" line265="            length = length &gt;&gt; 0;" line264="            start = start &gt;&gt; 0;" line263="        range(start: number, length: number): MoveMotorZIP {" line262="        //% block=&quot;%moveMotorZIP|range from %start|with %length|leds&quot;" line261="        //% blockId=&quot;kitronik_move_motor_range&quot; " line260="        //% weight=89 blockGap=8" line259="        //% subcategory=&quot;ZIP LEDs&quot;" line258="        */" line257="        * @param length number of LEDs in the range. eg: 4" line256="        * @param start offset in the LED strip to start the range" line255="        * Create a range of LEDs." line254="        /** " line253="" line252="        }" line251="            this.show();" line250="            }" line249="                }" line248="                    else this.setPixelRGB(k, 0);" line247="                    }" line246="                        this.setPixelRGB(k, rgb(g, 255 - g, 0));" line245="                        //this.setPixelRGB(i, moveMotorZIP.rgb(0, g, 255 - g));" line244="                        const g = Math.idiv(k * 255, n1);" line243="                    if (k &lt;= v) {" line242="                for (let k = 0; k &lt; n; ++k) {" line241="            } else {" line240="                    this.setPixelRGB(j, 0);" line239="                for (let j = 1; j &lt; n; ++j)" line238="                this.setPixelRGB(0, 0x666600);" line237="            if (v == 0) {" line236="            let v = Math.idiv((value * n), high);" line235="            const n1 = n - 1;" line234="            const n = this._length;" line233="            value = Math.abs(value);" line232="" line231="            }" line230="                return;" line229="                this.show();" line228="                this.setPixelRGB(0, 0xFFFF00);" line227="                this.clear();" line226="            if (high &lt;= 0) {" line225="        showBarGraph(value: number, high: number): void {" line224="        //% block=&quot;%moveMotorZIP|show bar graph of %value|up to %high&quot;" line223="        //% blockId=kitronik_move_motor_show_bar_graph " line222="        //% weight=84 blockGap=8" line221="        //% subcategory=&quot;ZIP LEDs&quot;" line220="         */" line219="         * @param high maximum value, eg: 255" line218="         * @param value current value to plot" line217="         * If `high` is 0, the chart gets adjusted automatically." line216="         * Displays a vertical bar graph based on the `value` and `high` value." line215="&#9;&#9;/**" line214="" line213="        }" line212="            this.show();" line211="            }" line210="                this.setPixelRGB(steps - 1, hsl(endHue, saturation, luminance));" line209="                }" line208="                    this.setPixelRGB(i, hsl(h, s, l));" line207="                    const l = Math.idiv((l1_100 + i * lStep), 100);" line206="                    const s = Math.idiv((s1_100 + i * sStep), 100);" line205="                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;" line204="                for (let i = 1; i &lt; steps - 1; i++) {" line203="                this.setPixelRGB(0, hsl(startHue, saturation, luminance));" line202="            } else {" line201="                this.setPixelRGB(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line200="            if (steps === 1) {" line199="            //interpolate" line198="" line197="            const l1_100 = l1 * 100" line196="            const lStep = Math.idiv(lDist, steps);" line195="            const lDist = l2 - l1;" line194="            const l2 = luminance;" line193="            const l1 = luminance;" line192="            //lum" line191="" line190="            const s1_100 = s1 * 100;" line189="            const sStep = Math.idiv(sDist, steps);" line188="            const sDist = s2 - s1;" line187="            const s2 = saturation;" line186="            const s1 = saturation;" line185="            //sat" line184="" line183="            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line182="            }" line181="                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line180="            } else {" line179="                hStep = hStepCCW;" line178="            } else if (direction === HueInterpolationDirection.CounterClockwise) {" line177="                hStep = hStepCW;" line176="            if (direction === HueInterpolationDirection.Clockwise) {" line175="            let hStep: number;" line174="            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line173="            const hDistCCW = ((h1 + 360) - h2) % 360;" line172="            const hStepCW = Math.idiv((hDistCW * 100), steps);" line171="            const hDistCW = ((h2 + 360) - h1) % 360;" line170="            const h2 = endHue;" line169="            const h1 = startHue;" line168="            //hue" line167="" line166="            const direction = HueInterpolationDirection.Clockwise;" line165="            const steps = this._length;" line164="            const luminance = 50;" line163="            const saturation = 100;" line162="            endHue = endHue &gt;&gt; 0;" line161="            startHue = startHue &gt;&gt; 0;" line160="" line159="            if (this._length &lt;= 0) return;" line158="        showRainbow(startHue: number = 1, endHue: number = 360) {" line157="        //% weight=94 blockGap=8" line156="        //% block=&quot;%moveMotorZIP|show rainbow from %startHue|to %endHue&quot;" line155="        //% blockId=&quot;kitronik_move_motor_rainbow&quot; 7" line154="        //% subcategory=&quot;ZIP LEDs&quot;" line153="         */" line152="         * @param endHue the end hue value for the rainbow, eg: 360" line151="         * @param startHue the start hue value for the rainbow, eg: 1" line150="         * Shows a rainbow pattern on all LEDs. " line149="        /**" line148="" line147="" line146="        _length: number;" line145="        start: number;" line144="        brightness: number;" line143="        pin: DigitalPin;" line142="        buf: Buffer;" line141="    export class MoveMotorZIP {" line140="" line139="    }" line138="        }" line137="            pins.digitalWritePin(DigitalPin.P12, 0);" line136="        else {" line135="        }" line134="            pins.digitalWritePin(DigitalPin.P12, 1);" line133="        if (illuminate == OnOffSelection.On) {" line132="    export function shineTailLight(illuminate: OnOffSelection): void {" line131="    //% block=&quot;turn tail light %illuminate&quot;" line130="    //% weight=95 blockGap=8" line129="    //% blockId=kitronik_move_motor_tail_light" line128="    //% group=Lights" line127="    */" line126="    * @param motor which motor to turn off" line125="    * Turns on and off the horn." line124="    /**" line123="" line122="    //////////////" line121="    //  LIGHTS  //" line120="    //////////////" line119="" line118="    }" line117="        initalised = true" line116="        sensorRightRef = pins.analogReadPin(AnalogPin.P2)" line115="        sensorLeftRef = pins.analogReadPin(AnalogPin.P1)" line114="" line113="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line112="        buf[1] = LED_OUT_VALUE" line111="        buf[0] = LED_OUT_ADDR" line110="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line109="        buf[1] = MODE_2_REG_VALUE" line108="        buf[0] = MODE_2_REG_ADDR" line107="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line106="        buf[1] = MODE_1_REG_VALUE" line105="        buf[0] = MODE_1_REG_ADDR" line104="" line103="        let buf = pins.createBuffer(2)" line102="    function setup(): void {" line101="    */" line100="&#9;&#9;This secret incantation sets up the PCA9632 I2C driver chip to be running " line99="&#9;/*" line98="" line97="" line96="    let detectionLevel = 45&#9;&#9;//reading is done by converting 0.13V into ADC reading (3/1024)*45, this is the default setting" line95="    let sensorRightRef = 0" line94="    let sensorLeftRef = 0" line93="    //Line following sensors global variables" line92="    let echoPin = DigitalPin.P14" line91="    let triggerPin = DigitalPin.P13" line90="    //Ultrasonic global variables" line89="    let sirenOn = false" line88="    //Motor global variables" line87="    let initalised = false //a flag to allow us to initialise without explicitly calling the secret incantation" line86="" line85="    }" line84="        Dark" line83="        //% block=&quot;Dark&quot;" line82="        Light," line81="        //% block=&quot;Light&quot;" line80="    export enum LightSelection {" line79="    //Light level detection mode selection" line78="    }" line77="        right" line76="        //% block=&quot;right&quot;" line75="        left," line74="        //% block=&quot;left&quot;" line73="    export enum LfSensor {" line72="    // Selection of line following sensor" line71="    /*LINE FOLLOWING*/" line70="" line69="    }" line68="        Inches" line67="        //% block=&quot;inches&quot;" line66="        Centimeters," line65="        //% block=&quot;cm&quot;" line64="    export enum Units {" line63="    // Units for ultrasonic sensors to measure" line62="    /*ULTRASONIC*/" line61="" line60="    }" line59="        Reverse" line58="        //% block=&quot;Reverse&quot;" line57="        Forward," line56="        //% block=&quot;Forward&quot;" line55="    export enum MotorDirection {" line54="    // Directions the motors can rotate." line53="    }" line52="        MotorRight = 0x04" line51="        //% block=&quot;Right&quot;" line50="        MotorLeft = 0x02," line49="        //% block=&quot;Left&quot;" line48="    export enum Motors {" line47="    // List of motors for the motor blocks to use. These represent register offsets in the PCA9865 driver IC." line46="    /*MOTORS*/" line45="" line44="    }" line43="        Black = 0x000000" line42="        //% block=black" line41="        White = 0xFFFFFF," line40="        //% block=white" line39="        Purple = 0xFF00FF," line38="        //% block=purple" line37="        Violet = 0x8a2be2," line36="        //% block=violet" line35="        Indigo = 0x4b0082," line34="        //% block=indigo" line33="        Blue = 0x0000FF," line32="        //% block=blue" line31="        Green = 0x00FF00," line30="        //% block=green" line29="        Yellow = 0xFFFF00," line28="        //% block=yellow" line27="        Orange = 0xFFA500," line26="        //% block=orange" line25="        Red = 0xFF0000," line24="        //% block=red" line23="    enum ZipLedColors {" line22="    //Well known colors for ZIP LEDs" line21="    /* ZIPLEDS*/" line20="" line19="    }" line18="        Off = 0" line17="        //% block=&quot;off&quot;" line16="        On = 1," line15="        //% block=&quot;on&quot;" line14="    export enum OnOffSelection {" line13="    /*GENERAL*/" line12="" line11="    let MOTOR_DUTY_CYCLE_RATION = 0.4" line10="" line9="    let LED_OUT_VALUE = 0xAA  //The mode 1 register address" line8="    let MODE_2_REG_VALUE = 0x10  //The mode 1 register address" line7="    let MODE_1_REG_VALUE = 0x00 //the prescale register address" line6="" line5="    let LED_OUT_ADDR = 0x08  //LED output register address" line4="    let MODE_2_REG_ADDR = 0x01  //mode 2 register address" line3="    let MODE_1_REG_ADDR = 0x00 //mode 1 register address" line2="    let CHIP_ADDR = 0xE0 // CHIP_ADDR is the standard chip address for the PCA9632" line1="    //Constants " line0="namespace Kitronik_Move_Motor {" numlines="755"></mutation><comment id="undefined" h="80" w="160" pinned="false">% weight=100 color=#00A654 icon="\uf1b9" block="Move Motor" % groups='["Lights", "Sensors", "Motors", "Sound"]'</comment><data>0</data></block></statement></block></xml>