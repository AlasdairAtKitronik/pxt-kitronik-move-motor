<xml xmlns="https://developers.google.com/blockly/xml"><block id="%CJ+W^4S3~x[3p5S38iE" type="pxt-on-start" x="0" y="0"><statement name="HANDLER"><block id=",81PfY}#LB!6:nsne=4n" type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line754="                basic.pause(75)" line753="                music.playTone(370, music.beat(BeatFraction.Half))" line752="            while (sirenOn) {" line751="            control.inBackground(() =&gt; {" line750="            sirenOn = true" line749="        if (siren == OnOffSelection.On) {" line748="    export function soundSiren(siren: OnOffSelection): void {" line747="    //% block=&quot;turn siren %siren&quot;" line746="    //% weight=95 blockGap=8" line745="    //% blockId=kitronik_move_motor_siren" line744="    //% subcategory=Sounds" line743="    */" line742="    * @param OnOffSelection which selects the status of the siren being on or off" line741="    * Turns on and off the siren that plays in the background." line740="    /**" line739="" line738="    }" line737="        }" line736="            basic.pause(75)" line735="            music.playTone(185, music.beat(BeatFraction.Quarter))" line734="            basic.pause(75)" line733="            music.playTone(185, music.beat(BeatFraction.Quarter))" line732="        for (let u = 0; u &lt;= hornTimes; u++) {" line731="    export function beepHorn(hornTimes: number): void {" line730="    //% hornTimes.min = 1 hornTimes.max = 5 hornTimes.defl = 1" line729="    //%block=&quot;beep the horn %hornTimes&quot;" line728="    //% weight=95 blockGap=8" line727="    //% blockId=kitronik_move_motor_horn" line726="    //% subcategory=Sounds" line725="     */" line724="     * @param hornTimes is the number of times the beep loops and sounds" line723="     * Sound the beep horn with a selected number of times." line722="    /**" line721="" line720="    //////////////" line719="    //  SOUNDS  //" line718="    //////////////" line717="" line716="" line715="    }" line714="        pins.i2cWriteBuffer(CHIP_ADDR, motorOffbuf, false)" line713="        motorOffbuf[1] = 0x00" line712="        motorOffbuf[0] = motor + 1" line711="        pins.i2cWriteBuffer(CHIP_ADDR, motorOffbuf, false)" line710="        motorOffbuf[1] = 0x00" line709="        motorOffbuf[0] = motor" line708="        let motorOffbuf = pins.createBuffer(2)" line707="    export function motorOff(motor: Motors): void {" line706="    //%block=&quot;turn off %motor| motor&quot;" line705="    //% weight=95 blockGap=8" line704="    //% blockId=kitronik_move_motor_motor_off" line703="    //% group=Motors" line702="    //% subcategory=Motors" line701="     */" line700="     * @param motor which motor to turn off" line699="     * Turns off the specified motor." line698="    /**" line697="" line696="    }" line695="" line694="" line693="        }" line692="            }" line691="                    break" line690="                    pins.i2cWriteBuffer(CHIP_ADDR, motorOnbuf, false)" line689="                    motorOnbuf[1] = 0x00" line688="                    motorOnbuf[0] = motor + 1" line687="                    pins.i2cWriteBuffer(CHIP_ADDR, motorOnbuf, false)" line686="                    motorOnbuf[1] = outputVal" line685="                    motorOnbuf[0] = motor" line684="                case MotorDirection.Reverse:" line683="                    break" line682="                    pins.i2cWriteBuffer(CHIP_ADDR, motorOnbuf, false)" line681="                    motorOnbuf[1] = outputVal" line680="                    motorOnbuf[0] = motor + 1" line679="                    pins.i2cWriteBuffer(CHIP_ADDR, motorOnbuf, false)" line678="                    motorOnbuf[1] = 0x00" line677="                    motorOnbuf[0] = motor" line676="                case MotorDirection.Forward:" line675="            switch (dir) {" line674="        else if (motor == Motors.MotorLeft){" line673="        }" line672="            }" line671="                    break" line670="                    pins.i2cWriteBuffer(CHIP_ADDR, motorOnbuf, false)" line669="                    motorOnbuf[1] = outputVal" line668="                    motorOnbuf[0] = motor + 1" line667="                    pins.i2cWriteBuffer(CHIP_ADDR, motorOnbuf, false)" line666="                    motorOnbuf[1] = 0x00" line665="                    motorOnbuf[0] = motor" line664="                case MotorDirection.Reverse:" line663="                    break" line662="                    pins.i2cWriteBuffer(CHIP_ADDR, motorOnbuf, false)" line661="                    motorOnbuf[1] = 0x00" line660="                    motorOnbuf[0] = motor + 1" line659="                    pins.i2cWriteBuffer(CHIP_ADDR, motorOnbuf, false)" line658="                    motorOnbuf[1] = outputVal" line657="                    motorOnbuf[0] = motor" line656="                case MotorDirection.Forward:" line655="            switch (dir) {" line654="        if (motor == Motors.MotorRight){" line653="        " line652="        let motorOnbuf = pins.createBuffer(2)" line651="" line650="        let outputVal = Math.round(speed/MOTOR_DUTY_CYCLE_RATION)" line649="        //let outputVal = Math.idiv(speed, MOTOR_DUTY_CYCLE_RATION)" line648="        /*convert 0-100 to 0-250 (approx) We wont worry about the last 5 to make life simpler*/" line647="" line646="        }" line645="            setup()" line644="        if (initalised == false) {" line643="    export function motorOn(motor: Motors, dir: MotorDirection, speed: number): void {" line642="    //% speed.min=0 speed.max=100" line641="    //% weight=100 blockGap=8" line640="    //% block=&quot;turn %motor|motor on direction %dir|speed %speed&quot;" line639="    //% blockId=kitronik_move_motor_motor_on" line638="    //% group=Motors" line637="    //% subcategory=Motors" line636="     */" line635="     * @param speed how fast to spin the motor" line634="     * @param dir   which direction to go" line633="     * @param motor which motor to turn on" line632="     * if the PCA has not yet been initialised calls the initialisation routine." line631="     * Sets the requested motor running in chosen direction at a set speed." line630="    /**" line629="" line628="    //////////////" line627="    //  MOTORS  //" line626="    //////////////" line625="" line624="    }" line623="        return result;" line622="        }" line621="            }" line620="                result = false" line619="            else {" line618="            }" line617="                result = true" line616="            if (value2 &lt;= (ref - detectionLevel)) {" line615="        else if (lightLevel == LightSelection.Dark) {" line614="        }" line613="            }" line612="                result = false" line611="            else {" line610="            }" line609="                result = true" line608="            if (value2 &gt;= (ref + detectionLevel)) {" line607="        if (lightLevel == LightSelection.Light) {" line606="" line605="        }" line604="            ref = sensorRightRef" line603="            value2 = pins.analogReadPin(AnalogPin.P2)" line602="        else if (pinSelected == LfSensor.right) {" line601="        }" line600="            ref = sensorLeftRef" line599="            value2 = pins.analogReadPin(AnalogPin.P1)" line598="        if (pinSelected == LfSensor.left) {" line597="" line596="        }" line595="            setup()" line594="        if (initalised == false) {" line593="" line592="        let result = false" line591="        let ref = 0" line590="        let value2 = 0" line589="    export function sensorDigitalDetection(pinSelected: LfSensor, lightLevel: LightSelection): boolean {" line588="    //% weight=95 blockGap=8" line587="    //% block=&quot;sensor on pin %pinSelected| detected %LightSelection&quot;" line586="    //% blockId=kitronik_move_motor_line_follower_digital_sensor" line585="    //% group=&quot;Line Following&quot;" line584="    //% subcategory=&quot;Sensors&quot;" line583="    */" line582="&#9;* @param lightSelection is the selection of the sensor detecting light or dark" line581="    * @param pinSelected is the selection of pin to read a particular sensor" line580="    * Sensor on pin detection returns a true or false when the sensor has detected" line579="    /**" line578="" line577="    }" line576="        return value;" line575="        }" line574="            value = pins.analogReadPin(AnalogPin.P1)" line573="        else if (sensorSelected == LfSensor.right) {" line572="        }" line571="            value = pins.analogReadPin(AnalogPin.P1)" line570="        if (sensorSelected == LfSensor.left) {" line569="" line568="        }" line567="            setup()" line566="        if (initalised == false) {" line565="" line564="        let value = 0" line563="    export function readSensor(sensorSelected: LfSensor) {" line562="    //% weight=90 blockGap=8" line561="    //% block=&quot;read sensor on pin %pinSelected&quot;" line560="    //% blockId=kitronik_move_motor_line_follower_read_sensor" line559="    //% group=&quot;Line Following&quot;" line558="    //% subcategory=&quot;Sensors&quot;" line557="    */" line556="    * @param pinSelected is the selection of pin to read a particular sensor" line555="    * Read sensor block allows user to read the value of the sensor (returns value in range 0-1023)" line554="    /**" line553="" line552="    }" line551="        detectionLevel = (level / 2) + 10" line550="        }" line549="            setup()" line548="        if (initalised == false) {" line547="    export function setSensorDetectionLevel(level: number) {" line546="    //% weight=85 blockGap=8" line545="    //% level.min=0 level.max=100 level.defl=50" line544="    //% block=&quot;set sensor threshold to %level|&quot;" line543="    //% blockId=kitronik_move_motor_line_follower_set_threshold" line542="    //% group=&quot;Line Following&quot;" line541="    //% subcategory=&quot;Sensors&quot;" line540="    */" line539="    * @param level is the threshold percentage" line538="    * Set sensor threshold block allows the user to adjust the point at which the sensor detects" line537="    /**" line536="" line535="" line534="    }" line533="        }" line532="            default: return 0;" line531="            case Units.Inches: return Math.idiv(pulse, 98);" line530="            case Units.Centimeters: return Math.idiv(pulse, 39);" line529="        switch (unit) {" line528="        //values have been changed to match the correct measured distances so 58 changed to 39 and 148 changed to 98" line527="        //When measured actual distance compared to calculated distanceis not the same.  There must be an timing measurement with the pulse." line526="        //From the HC-SR04 datasheet the formula for calculating distance is us of pulse / 58 for cm or us of pulse / 148 for inches." line525="        const pulse = pins.pulseIn(echoPin, PulseValue.High, maxCmDistance * 39);" line524="        // read pulse" line523="" line522="        pins.digitalWritePin(triggerPin, 0);" line521="        control.waitMicros(10);" line520="        pins.digitalWritePin(triggerPin, 1);" line519="        control.waitMicros(2);" line518="        pins.digitalWritePin(triggerPin, 0);" line517="        pins.setPull(triggerPin, PinPullMode.PullNone);" line516="        // send pulse" line515="    export function measure(unit: Units, maxCmDistance = 500): number {" line514="    //% block=&quot;measure distances in |unit %unit&quot;" line513="    //% blockId=kitronik_move_motor_ultrasonic_measure" line512="    //% group=&quot;Ultrasonic&quot;" line511="    //% subcategory=&quot;Sensors&quot;" line510="     */" line509="     * @param maxCmDistance maximum distance in centimeters (default is 500)" line508="     * @param unit desired conversion unit" line507="     * Measure the echo time (after trigger) and converts to cm or inches and returns as an int" line506="    /**" line505="    //////////////" line504="    //  SENSORS //" line503="    //////////////" line502="" line501="    }" line500="        Shortest" line499="        CounterClockwise," line498="        Clockwise," line497="    export enum HueInterpolationDirection {" line496="     */" line495="     * Options for direction hue changes, used by rainbow block (never visible to end user)" line494="    /**" line493="" line492="    }" line491="        return packRGB(t, q, d);" line490="        let d = b$ + p;" line489="        let q = g$ + p;" line488="        let t = r$ + p;" line487="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c), 2);" line486="        }" line485="            r$ = c; g$ = 0; b$ = x;" line484="        } else if (h12 == 5) {" line483="            r$ = x; g$ = 0; b$ = c;" line482="        } else if (h12 == 4) {" line481="            r$ = 0; g$ = x; b$ = c;" line480="        } else if (h12 == 3) {" line479="            r$ = 0; g$ = c; b$ = x;" line478="        } else if (h12 == 2) {" line477="            r$ = x; g$ = c; b$ = 0;" line476="        } else if (h12 == 1) {" line475="            r$ = c; g$ = x; b$ = 0;" line474="        if (h12 == 0) {" line473="        let b$: number;" line472="        let g$: number;" line471="        let r$: number;" line470="        let x = (c * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line469="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line468="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line467="        let h12 = Math.idiv(h, 60);//[0,6]" line466="        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line465="        l = Math.clamp(0, 99, l);" line464="        s = Math.clamp(0, 99, s);" line463="        h = h % 360;" line462="" line461="        l = Math.round(l);" line460="        s = Math.round(s);" line459="        h = Math.round(h);" line458="    function hsl(h: number, s: number, l: number): number {" line457="     */" line456="     * Converts a hue saturation luminosity value into a RGB color" line455="    /**" line454="" line453="    }" line452="        return b;" line451="        let b = (rgb) &amp; 0xFF;" line450="    function unpackB(rgb: number): number {" line449="    //Separates blue value from combined number" line448="    }" line447="        return o;" line446="        let o = (rgb &gt;&gt; 8) &amp; 0xFF;" line445="    function unpackG(rgb: number): number {" line444="    //Separates green value from combined number" line443="    }" line442="        return r;" line441="        let r = (rgb &gt;&gt; 16) &amp; 0xFF;" line440="    function unpackR(rgb: number): number {" line439="    //Separates red value from combined number" line438="    }" line437="        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);" line436="    function packRGB(a: number, b: number, c: number): number {" line435="    //Combines individual RGB settings to be a single number" line434="" line433="    }" line432="        return color;" line431="    export function colors(color: ZipLedColors): number {" line430="    //% blockId=&quot;kitronik_move_motor_colors&quot; block=&quot;%color&quot;" line429="    //% weight=2 blockGap=8" line428="    //% subcategory=&quot;Lights&quot;" line427="    */" line426="     * Gets the RGB value of a known color" line425="    /**" line424="" line423="    }" line422="        return packRGB(red, green, blue);" line421="    export function rgb(red: number, green: number, blue: number): number {" line420="    //% blockId=&quot;kitronik_move_motor_rgb&quot; block=&quot;red %red|green %green|blue %blue&quot;" line419="    //% weight=1 blockGap=8" line418="    //% subcategory=&quot;Lights&quot;" line417="     */" line416="     * @param blue value of the blue channel between 0 and 255. eg: 255" line415="     * @param green value of the green channel between 0 and 255. eg: 255" line414="     * @param red value of the red channel between 0 and 255. eg: 255" line413="     * Converts value to red, green, blue channels" line412="    /**" line411="" line410="    *   as we cant wavelength shift an actual LED... (Ye canna change the laws of physics Capt)*/" line409="    * &#9; We blend these linearly to give the impression of the other wavelengths. " line408="    /*  The LEDs we are using have centre wavelengths of 470nm (Blue) 525nm(Green) and 625nm (Red) " line407="" line406="    }" line405="        return moveMotorZIP;" line404="        pins.digitalWritePin(moveMotorZIP.pin, 8);" line403="        moveMotorZIP.pin = DigitalPin.P8;" line402="        moveMotorZIP.setBrightness(128)" line401="        moveMotorZIP._length = numZips;" line400="        moveMotorZIP.start = 0;" line399="        moveMotorZIP.buf = pins.createBuffer(numZips * 3);" line398="        let moveMotorZIP = new MoveMotorZIP();" line397="    export function createMoveMotorZIPLED(numZips: number): MoveMotorZIP {" line396="    //% blockSetVariable=moveMotorZIP" line395="    //% trackArgs=0,2" line394="    //% weight=99 blockGap=8" line393="    //% block=&quot;to MOVE Motor with %numZips|ZIP LEDs&quot;" line392="    //% blockId=&quot;kitronik_move_motor_ZIP_LED_create&quot; " line391="    //% subcategory=&quot;Lights&quot;" line390="     */" line389="&#9; * @param numZips number of leds in the strip, eg: 4" line388="     * Create a new ZIP LED driver for MOVE Motor board." line387="    /**" line386="" line385="    }" line384="        }" line383="            this.setBufferRGB(pixeloffset, red2, green2, blue2)" line382="" line381="            let blue2 = unpackB(rgb);" line380="            let green2 = unpackG(rgb);" line379="            let red2 = unpackR(rgb);" line378="" line377="            pixeloffset = (pixeloffset + this.start) * 3;" line376="" line375="                return;" line374="                || pixeloffset &gt;= this._length)" line373="            if (pixeloffset &lt; 0" line372="        private setPixelRGB(pixeloffset: number, rgb: number): void {" line371="        //Separates out Red, Green and Blue data and fills the LED control data buffer for a single LED" line370="" line369="        }" line368="            }" line367="                this.setBufferRGB(m * 3, red, green, blue)" line366="            for (let m = this.start; m &lt; end; ++m) {" line365="            const end = this.start + this._length;" line364="" line363="            let blue = unpackB(rgb);" line362="            let green = unpackG(rgb);" line361="            let red = unpackR(rgb);" line360="        private setAllRGB(rgb: number) {" line359="        //Separates out Red, Green and Blue data and fills the LED control data buffer for all LEDs" line358="" line357="        }" line356="            this.buf[offset + 2] = blue;" line355="            this.buf[offset + 1] = red;" line354="            this.buf[offset + 0] = green;" line353="        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {" line352="        //Sets up the buffer for pushing LED control data out to LEDs" line351="" line350="        }" line349="            basic.pause(1) //add a pause to stop wierdnesses" line348="            this.brightness = brightness &amp; 0xff;" line347="            }" line346="                brightness = 255" line345="            else if (brightness &gt; 255) {" line344="            }" line343="                brightness = 0" line342="            if (brightness &lt; 0) {" line341="            //Clamp incoming variable at 0-255 as values out of this range cause unexpected brightnesses as the lower level code only expects a byte." line340="        setBrightness(brightness: number): void {" line339="        //% brightness.min=0 brightness.max=255" line338="        //% weight=92 blockGap=8" line337="        //% block=&quot;%moveMotorZIP|set brightness %brightness&quot; " line336="        //% blockId=&quot;kitronik_move_motordisplay_set_brightness&quot;" line335="        //% subcategory=&quot;Lights&quot;" line334="         */" line333="         * @param brightness a measure of LED brightness in 0-255. eg: 255" line332="         * Set the brightness of the ZIP Halo display. This flag only applies to future show operation." line331="        /**" line330="" line329="        }" line328="            this.buf.fill(0, this.start * 3, this._length * 3);" line327="        clear(): void {" line326="        //% weight=95 blockGap=8" line325="        //% block=&quot;%moveMotorZIP|clear&quot;" line324="        //% blockId=&quot;kitronik_move_motor_display_clear&quot;" line323="        //% subcategory=&quot;Lights&quot;" line322="         */" line321="         * You need to call ``show`` to make the changes visible." line320="         * Turn off all LEDs on the ZIP Halo display." line319="        /**" line318="" line317="        }" line316="            ws2812b.sendBuffer(this.buf, this.pin, this.brightness);" line315="            //use the Kitronik version which respects brightness for all " line314="        show() {" line313="        //% weight=96" line312="        //% block=&quot;%moveMotorZIP|show&quot; blockGap=8" line311="        //% blockId=&quot;kitronik_move_motor_display_show&quot; " line310="        //% subcategory=&quot;Lights&quot;" line309="         */" line308="         * Send all the changes to the ZIP Halo display." line307="        /**" line306="" line305="        }" line304="            this.setPixelRGB(zipLedNum &gt;&gt; 0, rgb &gt;&gt; 0);" line303="        setZipLedColor(zipLedNum: number, rgb: number): void {" line302="        //% weight=98 blockGap=8" line301="        //% block=&quot;%moveMotorZIP|set ZIP LED %zipLedNum|to %rgb=kitronik_move_motor_colors&quot;" line300="        //% blockId=&quot;kitronik_move_motor_set_zip_color&quot; " line299="        //% subcategory=&quot;Lights&quot;" line298="         */" line297="         * @param rgb RGB color of the ZIP LED" line296="         * @param zipLedNum position of the ZIP LED in the string" line295="         * You need to call ``show changes`` to make the changes visible." line294="         * Set particular ZIP LED to a given color. " line293="        /**" line292="" line291="        }" line290="            this.show();" line289="            this.setAllRGB(rgb);" line288="            rgb = rgb &gt;&gt; 0;" line287="        showColor(rgb: number) {" line286="        //% weight=99 blockGap=8" line285="        //% block=&quot;%moveMotorZIP|show color %rgb=kitronik_move_motor_colors&quot;" line284="        //% blockId=&quot;kitronik_move_motor_display_set_strip_color&quot; " line283="        //% subcategory=&quot;Lights&quot;" line282="         */" line281="         * @param rgb RGB color of the LED" line280="         * Shows whole ZIP Halo display as a given color (range 0-255 for r, g, b). " line279="    &#9;/**" line278="        }" line277="            this.setAllRGB(rgb);" line276="            rgb = rgb &gt;&gt; 0;" line275="        setColor(rgb: number) {" line274="        //% weight=99 blockGap=8" line273="        //% block=&quot;%moveMotorZIP|set color %rgb=kitronik_move_motor_colors&quot;" line272="        //% blockId=&quot;kitronik_move_motor_display_only_set_strip_color&quot; " line271="        //% subcategory=&quot;Lights&quot;" line270="         */" line269="         * @param rgb RGB color of the LED" line268="         * Sets whole ZIP Halo display as a given color (range 0-255 for r, g, b). Call Show to make changes visible " line267="    &#9;/**" line266="        }" line265="            this.buf.rotate(-offset * 3, this.start * 3, this._length * 3)" line264="        rotate(offset: number = 1): void {" line263="        //% weight=93 blockGap=8" line262="        //% block=&quot;%moveMotorZIP|rotate ZIP LEDs by %offset&quot; " line261="        //% blockId=&quot;kitronik_move_motor_display_rotate&quot; " line260="        //% subcategory=&quot;Lights&quot;" line259="         */" line258="         * @param offset number of ZIP LEDs to rotate forward, eg: 1" line257="         * You need to call ``show`` to make the changes visible." line256="         * Rotate LEDs forward." line255="        /**" line254="" line253="        }" line252="            this.show();" line251="            }" line250="                }" line249="                    else this.setPixelRGB(k, 0);" line248="                    }" line247="                        this.setPixelRGB(k, rgb(g, 255 - g, 0));" line246="                        //this.setPixelRGB(i, moveMotorZIP.rgb(0, g, 255 - g));" line245="                        const g = Math.idiv(k * 255, n1);" line244="                    if (k &lt;= v) {" line243="                for (let k = 0; k &lt; n; ++k) {" line242="            } else {" line241="                    this.setPixelRGB(j, 0);" line240="                for (let j = 1; j &lt; n; ++j)" line239="                this.setPixelRGB(0, 0x666600);" line238="            if (v == 0) {" line237="            let v = Math.idiv((value * n), high);" line236="            const n1 = n - 1;" line235="            const n = this._length;" line234="            value = Math.abs(value);" line233="" line232="            }" line231="                return;" line230="                this.show();" line229="                this.setPixelRGB(0, 0xFFFF00);" line228="                this.clear();" line227="            if (high &lt;= 0) {" line226="        showBarGraph(value: number, high: number): void {" line225="        //% block=&quot;%moveMotorZIP|show bar graph of %value|up to %high&quot;" line224="        //% blockId=kitronik_move_motor_show_bar_graph " line223="        //% weight=84 blockGap=8" line222="        //% subcategory=&quot;Lights&quot;" line221="         */" line220="         * @param high maximum value, eg: 255" line219="         * @param value current value to plot" line218="         * If `high` is 0, the chart gets adjusted automatically." line217="         * Displays a vertical bar graph based on the `value` and `high` value." line216="&#9;&#9;/**" line215="" line214="        }" line213="            this.show();" line212="            }" line211="                this.setPixelRGB(steps - 1, hsl(endHue, saturation, luminance));" line210="                }" line209="                    this.setPixelRGB(i, hsl(h, s, l));" line208="                    const l = Math.idiv((l1_100 + i * lStep), 100);" line207="                    const s = Math.idiv((s1_100 + i * sStep), 100);" line206="                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;" line205="                for (let i = 1; i &lt; steps - 1; i++) {" line204="                this.setPixelRGB(0, hsl(startHue, saturation, luminance));" line203="            } else {" line202="                this.setPixelRGB(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line201="            if (steps === 1) {" line200="            //interpolate" line199="" line198="            const l1_100 = l1 * 100" line197="            const lStep = Math.idiv(lDist, steps);" line196="            const lDist = l2 - l1;" line195="            const l2 = luminance;" line194="            const l1 = luminance;" line193="            //lum" line192="" line191="            const s1_100 = s1 * 100;" line190="            const sStep = Math.idiv(sDist, steps);" line189="            const sDist = s2 - s1;" line188="            const s2 = saturation;" line187="            const s1 = saturation;" line186="            //sat" line185="" line184="            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line183="            }" line182="                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line181="            } else {" line180="                hStep = hStepCCW;" line179="            } else if (direction === HueInterpolationDirection.CounterClockwise) {" line178="                hStep = hStepCW;" line177="            if (direction === HueInterpolationDirection.Clockwise) {" line176="            let hStep: number;" line175="            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line174="            const hDistCCW = ((h1 + 360) - h2) % 360;" line173="            const hStepCW = Math.idiv((hDistCW * 100), steps);" line172="            const hDistCW = ((h2 + 360) - h1) % 360;" line171="            const h2 = endHue;" line170="            const h1 = startHue;" line169="            //hue" line168="" line167="            const direction = HueInterpolationDirection.Clockwise;" line166="            const steps = this._length;" line165="            const luminance = 50;" line164="            const saturation = 100;" line163="            endHue = endHue &gt;&gt; 0;" line162="            startHue = startHue &gt;&gt; 0;" line161="" line160="            if (this._length &lt;= 0) return;" line159="        showRainbow(startHue: number = 1, endHue: number = 360) {" line158="        //% weight=94 blockGap=8" line157="        //% block=&quot;%moveMotorZIP|show rainbow from %startHue|to %endHue&quot;" line156="        //% blockId=&quot;kitronik_move_motor_rainbow&quot;" line155="        //% subcategory=&quot;Lights&quot;" line154="         */" line153="         * @param endHue the end hue value for the rainbow, eg: 360" line152="         * @param startHue the start hue value for the rainbow, eg: 1" line151="         * Shows a rainbow pattern on all LEDs. " line150="        /**" line149="" line148="" line147="        _length: number;" line146="        start: number;" line145="        brightness: number;" line144="        pin: DigitalPin;" line143="        buf: Buffer;" line142="    export class MoveMotorZIP {" line141="" line140="    }" line139="        }" line138="            pins.digitalWritePin(DigitalPin.P12, 0);" line137="        else {" line136="        }" line135="            pins.digitalWritePin(DigitalPin.P12, 1);" line134="        if (illuminate == OnOffSelection.On) {" line133="    export function shineTailLight(illuminate: OnOffSelection): void {" line132="    //% block=&quot;turn tail light %illuminate&quot;" line131="    //% weight=100 blockGap=8" line130="    //% blockId=kitronik_move_motor_tail_light" line129="    //% subcategory=&quot;Lights&quot;" line128="    */" line127="    * @param illuminate which selects the LED to turn on or off" line126="    * Turns on and off the tail light." line125="    /**" line124="" line123="    //////////////" line122="    //  LIGHTS  //" line121="    //////////////" line120="" line119="    }" line118="        initalised = true" line117="        sensorRightRef = pins.analogReadPin(AnalogPin.P2)" line116="        sensorLeftRef = pins.analogReadPin(AnalogPin.P1)" line115="" line114="        basic.pause(1)" line113="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line112="        buf[1] = MOTOR_OUT_VALUE" line111="        buf[0] = MOTOR_OUT_ADDR" line110="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line109="        buf[1] = MODE_2_REG_VALUE" line108="        buf[0] = MODE_2_REG_ADDR" line107="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line106="        buf[1] = MODE_1_REG_VALUE" line105="        buf[0] = MODE_1_REG_ADDR" line104="" line103="        let buf = pins.createBuffer(2)" line102="    function setup(): void {" line101="    */" line100="&#9;&#9;This secret incantation sets up the PCA9632 I2C driver chip to be running " line99="&#9;/*" line98="" line97="" line96="    let detectionLevel = 45&#9;&#9;//reading is done by converting 0.13V into ADC reading (3/1024)*45, this is the default setting" line95="    let sensorRightRef = 0" line94="    let sensorLeftRef = 0" line93="    //Line following sensors global variables" line92="    let echoPin = DigitalPin.P14" line91="    let triggerPin = DigitalPin.P13" line90="    //Ultrasonic global variables" line89="    let sirenOn = false" line88="    //Motor global variables" line87="    let initalised = false //a flag to allow us to initialise without explicitly calling the secret incantation" line86="" line85="    }" line84="        Dark" line83="        //% block=&quot;Dark&quot;" line82="        Light," line81="        //% block=&quot;Light&quot;" line80="    export enum LightSelection {" line79="    //Light level detection mode selection" line78="    }" line77="        right" line76="        //% block=&quot;right&quot;" line75="        left," line74="        //% block=&quot;left&quot;" line73="    export enum LfSensor {" line72="    // Selection of line following sensor" line71="    /*LINE FOLLOWING*/" line70="" line69="    }" line68="        Inches" line67="        //% block=&quot;inches&quot;" line66="        Centimeters," line65="        //% block=&quot;cm&quot;" line64="    export enum Units {" line63="    // Units for ultrasonic sensors to measure" line62="    /*ULTRASONIC*/" line61="" line60="    }" line59="        Reverse" line58="        //% block=&quot;Reverse&quot;" line57="        Forward," line56="        //% block=&quot;Forward&quot;" line55="    export enum MotorDirection {" line54="    // Directions the motors can rotate." line53="    }" line52="        MotorRight = 0x04" line51="        //% block=&quot;Right&quot;" line50="        MotorLeft = 0x02," line49="        //% block=&quot;Left&quot;" line48="    export enum Motors {" line47="    // List of motors for the motor blocks to use. These represent register offsets in the PCA9832 driver IC." line46="    /*MOTORS*/" line45="" line44="    }" line43="        Black = 0x000000" line42="        //% block=black" line41="        White = 0xFFFFFF," line40="        //% block=white" line39="        Purple = 0xFF00FF," line38="        //% block=purple" line37="        Violet = 0x8a2be2," line36="        //% block=violet" line35="        Indigo = 0x4b0082," line34="        //% block=indigo" line33="        Blue = 0x0000FF," line32="        //% block=blue" line31="        Green = 0x00FF00," line30="        //% block=green" line29="        Yellow = 0xFFFF00," line28="        //% block=yellow" line27="        Orange = 0xFFA500," line26="        //% block=orange" line25="        Red = 0xFF0000," line24="        //% block=red" line23="    export enum ZipLedColors {" line22="    //Well known colors for ZIP LEDs" line21="    /* ZIPLEDS*/" line20="" line19="    }" line18="        Off = 0" line17="        //% block=&quot;off&quot;" line16="        On = 1," line15="        //% block=&quot;on&quot;" line14="    export enum OnOffSelection {" line13="    /*GENERAL*/" line12="" line11="    let MOTOR_DUTY_CYCLE_RATION = 0.4" line10="" line9="    let MOTOR_OUT_VALUE = 0xAA  //Outputs set to be controled PWM registers" line8="    let MODE_2_REG_VALUE = 0x04  //Setup to make changes on ACK, outputs set to open-drain" line7="    let MODE_1_REG_VALUE = 0x00 //setup to normal mode and not to respond to sub address" line6="" line5="    let MOTOR_OUT_ADDR = 0x08  //MOTOR output register address" line4="    let MODE_2_REG_ADDR = 0x01  //mode 2 register address" line3="    let MODE_1_REG_ADDR = 0x00 //mode 1 register address" line2="    let CHIP_ADDR = 0x62 // CHIP_ADDR is the standard chip address for the PCA9632, datasheet refers to LED control but chip is used for PWM to motor driver" line1="    //Constants " line0="namespace Kitronik_Move_Motor {" numlines="767" line766="}" line765="    }" line764="        }" line763="            music.stopMelody(MelodyStopOptions.Background)" line762="            sirenOn = false" line761="        else {" line760="        }" line759="        })" line758="" line757="            }" line756="                basic.pause(75)" line755="                music.playTone(262, music.beat(BeatFraction.Half))"></mutation></block></statement></block></xml>