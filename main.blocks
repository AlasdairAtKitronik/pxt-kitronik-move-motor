<xml xmlns="https://developers.google.com/blockly/xml"><comment id="2v%yxqT5i+$D9[#aV/#[" h="120" x="0" y="0" data="0" w="480">Blocks for driving the Kitronik MOVE Motor Board</comment><block id="I;9F7[(m;bov^XwG|/Na" type="pxt-on-start" x="10" y="10"><statement name="HANDLER"><block id="%BA-I8,Lxrh4m#.[+W1V" type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line776="    }" line775="        })" line774="" line773="            }" line772="                basic.pause(75)" line771="                music.playTone(262, music.beat(BeatFraction.Half))" line770="                basic.pause(75)" line769="                music.playTone(370, music.beat(BeatFraction.Half))" line768="            while (sirenOn) {" line767="        control.inBackground(() =&gt; {" line766="    function turnOnSiren(): void {" line765="" line764="    }" line763="        }" line762="            sirenOn = false" line761="        else {" line760="        }" line759="            turnOnSiren()" line758="            sirenOn = true" line757="        if (siren == OnOffSelection.On) {" line756="    export function soundSiren(siren: OnOffSelection): void {" line755="    //% block=&quot;turn siren %siren&quot;" line754="    //% weight=95 blockGap=8" line753="    //% blockId=kitronik_move_motor_siren" line752="    //% group=Sounds" line751="    //% subcategory=Sounds" line750="    */" line749="    * @param siren is the selection to turn on or off the siren" line748="    * Turns on and off the horn." line747="    /**" line746="" line745="    }" line744="        }" line743="            basic.pause(75)" line742="            music.playTone(185, music.beat(BeatFraction.Quarter))" line741="            basic.pause(75)" line740="            music.playTone(185, music.beat(BeatFraction.Quarter))" line739="        for (let u = 0; u &lt;= hornTimes; u++) {" line738="    export function beepHorn(hornTimes: number): void {" line737="    //% hornTimes.min = 1 hornTimes.max = 5 hornTimes.defl = 1" line736="    //% block=&quot;beep the horn %hornTimes&quot;" line735="    //% weight=95 blockGap=8" line734="    //% blockId=kitronik_move_motor_horn" line733="    //% group=Sounds" line732="    //% subcategory=Sounds" line731="     */" line730="     * @param hornTimes is the number of times to sound the horn" line729="     * Turns on and off the horn." line728="    /**" line727="" line726="    //////////////" line725="    //  SOUNDS  //" line724="    //////////////" line723="" line722="" line721="    }" line720="        pins.i2cWriteBuffer(CHIP_ADDR, buf3, false)" line719="        buf3[1] = 0x00" line718="        buf3[0] = motor + 1" line717="        pins.i2cWriteBuffer(CHIP_ADDR, buf3, false)" line716="        buf3[1] = 0x00" line715="        buf3[0] = motor" line714="        let buf3 = pins.createBuffer(2)" line713="    export function motorOff(motor: Motors): void {" line712="    //%block=&quot;turn off %motor| motor&quot;" line711="    //% weight=95 blockGap=8" line710="    //% blockId=kitronik_move_motor_motor_off" line709="    //% group=Motors" line708="    //% subcategory=Motors" line707="     */" line706="     * @param motor which motor to turn off" line705="     * Turns off the specified motor." line704="    /**" line703="" line702="    }" line701="        }" line700="                break" line699="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line698="                buf2[1] = 0x00" line697="                buf2[0] = motor" line696="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line695="                buf2[1] = outputVal" line694="                buf2[0] = motor + 1" line693="            case MotorDirection.Reverse:" line692="                break" line691="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line690="                buf2[1] = 0x00" line689="                buf2[0] = motor + 1" line688="                pins.i2cWriteBuffer(CHIP_ADDR, buf2, false)" line687="                buf2[1] = outputVal" line686="                buf2[0] = motor" line685="            case MotorDirection.Forward:" line684="        switch (dir) {" line683="" line682="        let buf2 = pins.createBuffer(2)" line681="" line680="        let outputVal = Math.idiv(speed, MOTOR_DUTY_CYCLE_RATION)" line679="        /*convert 0-100 to 0-250 (approx) We wont worry about the last 95 to make life simpler*/" line678="" line677="        }" line676="            setup()" line675="        if (initalised == false) {" line674="    export function motorOn(motor: Motors, dir: MotorDirection, speed: number): void {" line673="    //% speed.min=0 speed.max=100" line672="    //% weight=100 blockGap=8" line671="    //% block=&quot;turn %motor|motor on direction %dir|speed %speed&quot;" line670="    //% blockId=kitronik_move_motor_motor_on" line669="    //% group=Motors" line668="    //% subcategory=Motors" line667="     */" line666="     * @param speed how fast to spin the motor" line665="     * @param dir   which direction to go" line664="     * @param motor which motor to turn on" line663="     * if the PCA has not yet been initialised calls the initialisation routine." line662="     * Sets the requested motor running in chosen direction at a set speed." line661="    /**" line660="" line659="    //////////////" line658="    //  MOTORS  //" line657="    //////////////" line656="" line655="    }" line654="        return result;" line653="        }" line652="            }" line651="                result = false" line650="            else {" line649="            }" line648="                result = true" line647="            if (value2 &lt;= (ref - detectionLevel)) {" line646="        else if (lightLevel == LightSelection.Dark) {" line645="        }" line644="            }" line643="                result = false" line642="            else {" line641="            }" line640="                result = true" line639="            if (value2 &gt;= (ref + detectionLevel)) {" line638="        if (lightLevel == LightSelection.Light) {" line637="" line636="        }" line635="            ref = sensorRightRef" line634="            value2 = pins.analogReadPin(AnalogPin.P2)" line633="        else if (pinSelected == LfSensor.right) {" line632="        }" line631="            ref = sensorLeftRef" line630="            value2 = pins.analogReadPin(AnalogPin.P1)" line629="        if (pinSelected == LfSensor.left) {" line628="" line627="        }" line626="            setup()" line625="        if (initalised == false) {" line624="" line623="        let result = false" line622="        let ref = 0" line621="        let value2 = 0" line620="    export function sensorDigitalDetection(pinSelected: LfSensor, lightLevel: LightSelection): boolean {" line619="    //% weight=95 blockGap=8" line618="    //% block=&quot;sensor on pin %pinSelected| detected %LightSelection&quot;" line617="    //% blockId=kitronik_move_motor_line_follower_digital_sensor" line616="    //% group=&quot;Line Following&quot;" line615="    //% subcategory=Sensors" line614="    */" line613="&#9;* @param lightSelection is the selection of the sensor detecting light or dark" line612="    * @param pinSelected is the selection of pin to read a particular sensor" line611="    * Sensor on pin detection returns a true or false when the sensor has detected" line610="    /**" line609="" line608="    }" line607="        return value;" line606="        }" line605="            value = pins.analogReadPin(AnalogPin.P1)" line604="        else if (sensorSelected == LfSensor.right) {" line603="        }" line602="            value = pins.analogReadPin(AnalogPin.P1)" line601="        if (sensorSelected == LfSensor.left) {" line600="" line599="        }" line598="            setup()" line597="        if (initalised == false) {" line596="" line595="        let value = 0" line594="    export function readSensor(sensorSelected: LfSensor) {" line593="    //% weight=90 blockGap=8" line592="    //% block=&quot;read sensor on pin %pinSelected&quot;" line591="    //% blockId=kitronik_move_motor_line_follower_read_sensor" line590="    //% group=&quot;Line Following&quot;" line589="    //% subcategory=Sensors" line588="    */" line587="    * @param pinSelected is the selection of pin to read a particular sensor" line586="    * Read sensor block allows user to read the value of the sensor (returns value in range 0-1023)" line585="    /**" line584="" line583="    }" line582="        detectionLevel = (level / 2) + 10" line581="        }" line580="            setup()" line579="        if (initalised == false) {" line578="    export function setSensorDetectionLevel(level: number) {" line577="    //% weight=85 blockGap=8" line576="    //% level.min=0 level.max=100 level.defl=50" line575="    //% block=&quot;set sensor threshold to %level|&quot;" line574="    //% blockId=kitronik_move_motor_line_follower_set_threshold" line573="    //% group=&quot;Line Following&quot;" line572="    //% subcategory=Sensors" line571="    */" line570="    * @param level is the threshold percentage" line569="    * Set sensor threshold block allows the user to adjust the point at which the sensor detects" line568="    /**" line567="" line566="" line565="    }" line564="        }" line563="            default: return 0;" line562="            case Units.Inches: return Math.idiv(pulse, 98);" line561="            case Units.Centimeters: return Math.idiv(pulse, 39);" line560="        switch (unit) {" line559="        const pulse = pins.pulseIn(echoPin, PulseValue.High, maxCmDistance * 39);" line558="        // read pulse" line557="" line556="        pins.digitalWritePin(triggerPin, 0);" line555="        control.waitMicros(10);" line554="        pins.digitalWritePin(triggerPin, 1);" line553="        control.waitMicros(2);" line552="        pins.digitalWritePin(triggerPin, 0);" line551="        pins.setPull(triggerPin, PinPullMode.PullNone);" line550="        // send pulse" line549="    export function measure(unit: Units, maxCmDistance = 500): number {" line548="    //% block=&quot;measure distances in |unit %unit&quot;" line547="    //% blockId=kitronik_move_motor_ultrasonic_measure" line546="    //% group=&quot;Ultrasonic&quot;" line545="    //% subcategory=Sensors" line544="     */" line543="     * @param maxCmDistance maximum distance in centimeters (default is 500)" line542="     * @param unit desired conversion unit" line541="     * Measure the echo time (after trigger) and converts to cm or inches and returns as an int" line540="    /**" line539="    //////////////" line538="    //  SENSORS //" line537="    //////////////" line536="" line535="    }" line534="        Shortest" line533="        CounterClockwise," line532="        Clockwise," line531="    export enum HueInterpolationDirection {" line530="     */" line529="     * Options for direction hue changes, used by rainbow block (never visible to end user)" line528="    /**" line527="" line526="    }" line525="        return packRGB(t, q, d);" line524="        let d = b$ + p;" line523="        let q = g$ + p;" line522="        let t = r$ + p;" line521="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c), 2);" line520="        }" line519="            r$ = c; g$ = 0; b$ = x;" line518="        } else if (h12 == 5) {" line517="            r$ = x; g$ = 0; b$ = c;" line516="        } else if (h12 == 4) {" line515="            r$ = 0; g$ = x; b$ = c;" line514="        } else if (h12 == 3) {" line513="            r$ = 0; g$ = c; b$ = x;" line512="        } else if (h12 == 2) {" line511="            r$ = x; g$ = c; b$ = 0;" line510="        } else if (h12 == 1) {" line509="            r$ = c; g$ = x; b$ = 0;" line508="        if (h12 == 0) {" line507="        let b$: number;" line506="        let g$: number;" line505="        let r$: number;" line504="        let x = (c * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line503="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line502="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line501="        let h12 = Math.idiv(h, 60);//[0,6]" line500="        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line499="        l = Math.clamp(0, 99, l);" line498="        s = Math.clamp(0, 99, s);" line497="        h = h % 360;" line496="" line495="        l = Math.round(l);" line494="        s = Math.round(s);" line493="        h = Math.round(h);" line492="    function hsl(h: number, s: number, l: number): number {" line491="     */" line490="     * Converts a hue saturation luminosity value into a RGB color" line489="    /**" line488="" line487="    }" line486="        return b;" line485="        let b = (rgb) &amp; 0xFF;" line484="    function unpackB(rgb: number): number {" line483="    //Separates blue value from combined number" line482="    }" line481="        return o;" line480="        let o = (rgb &gt;&gt; 8) &amp; 0xFF;" line479="    function unpackG(rgb: number): number {" line478="    //Separates green value from combined number" line477="    }" line476="        return r;" line475="        let r = (rgb &gt;&gt; 16) &amp; 0xFF;" line474="    function unpackR(rgb: number): number {" line473="    //Separates red value from combined number" line472="    }" line471="        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);" line470="    function packRGB(a: number, b: number, c: number): number {" line469="    //Combines individual RGB settings to be a single number" line468="" line467="    }" line466="        return color;" line465="    export function colors(color: ZipLedColors): number {" line464="    //% blockId=&quot;kitronik_move_motor_colors&quot; block=&quot;%color&quot;" line463="    //% weight=2 blockGap=8" line462="    //% group=&quot;ZIP LEDs&quot;" line461="    //% subcategory=Lights" line460="    */" line459="     * Gets the RGB value of a known color" line458="    /**" line457="" line456="    }" line455="        return packRGB(red, green, blue);" line454="    export function rgb(red: number, green: number, blue: number): number {" line453="    //% blockId=&quot;kitronik_move_motor_rgb&quot; block=&quot;red %red|green %green|blue %blue&quot;" line452="    //% weight=1 blockGap=8" line451="    //% group=&quot;ZIP LEDs&quot;" line450="    //% subcategory=Lights" line449="     */" line448="     * @param blue value of the blue channel between 0 and 255. eg: 255" line447="     * @param green value of the green channel between 0 and 255. eg: 255" line446="     * @param red value of the red channel between 0 and 255. eg: 255" line445="     * Converts value to red, green, blue channels" line444="    /**" line443="" line442="    *   as we cant wavelength shift an actual LED... (Ye canna change the laws of physics Capt)*/" line441="    * &#9; We blend these linearly to give the impression of the other wavelengths. " line440="    /*  The LEDs we are using have centre wavelengths of 470nm (Blue) 525nm(Green) and 625nm (Red) " line439="" line438="    }" line437="        return moveMotorZIP2;" line436="        pins.digitalWritePin(moveMotorZIP2.pin, 8);" line435="        moveMotorZIP2.pin = DigitalPin.P8;" line434="        moveMotorZIP2.setBrightness(128)" line433="        moveMotorZIP2._length = numZips;" line432="        moveMotorZIP2.start = 0;" line431="        moveMotorZIP2.buf = pins.createBuffer(numZips * 3);" line430="        let moveMotorZIP2 = new MoveMotorZIP();" line429="    export function createMoveMotorZIPLED(numZips: number): MoveMotorZIP {" line428="    //% blockSetVariable=moveMotorZIP" line427="    //% trackArgs=0,2" line426="    //% weight=100 blockGap=8" line425="    //% block=&quot;to Halo HD with %numZips|ZIP LEDs&quot;" line424="    //% blockId=&quot;kitronik_move_motor_ZIP_LED_create&quot; " line423="    //% group=&quot;ZIP LEDs&quot;" line422="    //% subcategory=Lights" line421="     */" line420="&#9; * @param numZips number of leds in the strip, eg: 4" line419="     * Create a new ZIP LED driver for MOVE Motor board." line418="    /**" line417="" line416="    }" line415="        }" line414="            this.setBufferRGB(pixeloffset, red2, green2, blue2)" line413="" line412="            let blue2 = unpackB(rgb);" line411="            let green2 = unpackG(rgb);" line410="            let red2 = unpackR(rgb);" line409="" line408="            pixeloffset = (pixeloffset + this.start) * 3;" line407="" line406="                return;" line405="                || pixeloffset &gt;= this._length)" line404="            if (pixeloffset &lt; 0" line403="        private setPixelRGB(pixeloffset: number, rgb: number): void {" line402="        //Separates out Red, Green and Blue data and fills the LED control data buffer for a single LED" line401="" line400="        }" line399="            }" line398="                this.setBufferRGB(m * 3, red, green, blue)" line397="            for (let m = this.start; m &lt; end; ++m) {" line396="            const end = this.start + this._length;" line395="" line394="            let blue = unpackB(rgb);" line393="            let green = unpackG(rgb);" line392="            let red = unpackR(rgb);" line391="        private setAllRGB(rgb: number) {" line390="        //Separates out Red, Green and Blue data and fills the LED control data buffer for all LEDs" line389="" line388="        }" line387="            this.buf[offset + 2] = blue;" line386="            this.buf[offset + 1] = red;" line385="            this.buf[offset + 0] = green;" line384="        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {" line383="        //Sets up the buffer for pushing LED control data out to LEDs" line382="" line381="        }" line380="            basic.pause(1) //add a pause to stop wierdnesses" line379="            this.brightness = brightness &amp; 0xff;" line378="            }" line377="                brightness = 255" line376="            else if (brightness &gt; 255) {" line375="            }" line374="                brightness = 0" line373="            if (brightness &lt; 0) {" line372="            //Clamp incoming variable at 0-255 as values out of this range cause unexpected brightnesses as the lower level code only expects a byte." line371="        setBrightness(brightness: number): void {" line370="        //% brightness.min=0 brightness.max=255" line369="        //% weight=92 blockGap=8" line368="        //% block=&quot;%moveMotorZIP|set brightness %brightness&quot; " line367="        //% blockId=&quot;kitronik_move_motordisplay_set_brightness&quot;" line366="        //% group=&quot;ZIP LEDs&quot;" line365="        //% subcategory=Lights" line364="         */" line363="         * @param brightness a measure of LED brightness in 0-255. eg: 255" line362="         * Set the brightness of the ZIP Halo display. This flag only applies to future show operation." line361="        /**" line360="" line359="        }" line358="            this.buf.fill(0, this.start * 3, this._length * 3);" line357="        clear(): void {" line356="        //% weight=95 blockGap=8" line355="        //% block=&quot;%moveMotorZIP|clear&quot;" line354="        //% blockId=&quot;kitronik_move_motor_display_clear&quot;" line353="        //% group=&quot;ZIP LEDs&quot;" line352="        //% subcategory=Lights" line351="         */" line350="         * You need to call ``show`` to make the changes visible." line349="         * Turn off all LEDs on the ZIP Halo display." line348="        /**" line347="" line346="        }" line345="            ws2812b.sendBuffer(this.buf, this.pin, this.brightness);" line344="            //use the Kitronik version which respects brightness for all " line343="        show() {" line342="        //% weight=96" line341="        //% block=&quot;%moveMotorZIP|show&quot; blockGap=8" line340="        //% blockId=&quot;kitronik_move_motor_display_show&quot; " line339="        //% group=&quot;ZIP LEDs&quot;" line338="        //% subcategory=Lights" line337="         */" line336="         * Send all the changes to the ZIP Halo display." line335="        /**" line334="" line333="        }" line332="            this.setPixelRGB(zipLedNum &gt;&gt; 0, rgb &gt;&gt; 0);" line331="        setZipLedColor(zipLedNum: number, rgb: number): void {" line330="        //% weight=98 blockGap=8" line329="        //% block=&quot;%moveMotorZIP|set ZIP LED %zipLedNum|to %rgb=kitronik_move_motor_colors&quot;" line328="        //% blockId=&quot;kitronik_move_motor_set_zip_color&quot; " line327="        //% group=&quot;ZIP LEDs&quot;" line326="        //% subcategory=Lights" line325="         */" line324="         * @param rgb RGB color of the ZIP LED" line323="         * @param zipLedNum position of the ZIP LED in the string" line322="         * You need to call ``show changes`` to make the changes visible." line321="         * Set particular ZIP LED to a given color. " line320="        /**" line319="" line318="        }" line317="            this.show();" line316="            this.setAllRGB(rgb);" line315="            rgb = rgb &gt;&gt; 0;" line314="        showColor(rgb: number) {" line313="        //% weight=99 blockGap=8" line312="        //% block=&quot;%moveMotorZIP|show color %rgb=kitronik_move_motor_colors&quot;" line311="        //% blockId=&quot;kitronik_move_motor_display_set_strip_color&quot; " line310="        //% group=&quot;ZIP LEDs&quot;" line309="        //% subcategory=Lights" line308="         */" line307="         * @param rgb RGB color of the LED" line306="         * Shows whole ZIP Halo display as a given color (range 0-255 for r, g, b). " line305="    &#9;/**" line304="        }" line303="            this.setAllRGB(rgb);" line302="            rgb = rgb &gt;&gt; 0;" line301="        setColor(rgb: number) {" line300="        //% weight=99 blockGap=8" line299="        //% block=&quot;%moveMotorZIP|set color %rgb=kitronik_move_motor_colors&quot;" line298="        //% blockId=&quot;kitronik_move_motor_display_only_set_strip_color&quot; " line297="        //% group=&quot;ZIP LEDs&quot;" line296="        //% subcategory=Lights" line295="         */" line294="         * @param rgb RGB color of the LED" line293="         * Sets whole ZIP Halo display as a given color (range 0-255 for r, g, b). Call Show to make changes visible " line292="    &#9;/**" line291="        }" line290="            this.buf.rotate(-offset * 3, this.start * 3, this._length * 3)" line289="        rotate(offset: number = 1): void {" line288="        //% weight=93 blockGap=8" line287="        //% block=&quot;%moveMotorZIP|rotate ZIP LEDs by %offset&quot; " line286="        //% blockId=&quot;kitronik_move_motor_display_rotate&quot; " line285="        //% group=&quot;ZIP LEDs&quot;" line284="        //% subcategory=Lights" line283="         */" line282="         * @param offset number of ZIP LEDs to rotate forward, eg: 1" line281="         * You need to call ``show`` to make the changes visible." line280="         * Rotate LEDs forward." line279="        /**" line278="" line277="        }" line276="            return moveMotorZIP;" line275="            moveMotorZIP._length = Math.clamp(0, this._length - (moveMotorZIP.start - this.start), length);" line274="            moveMotorZIP.start = this.start + Math.clamp(0, this._length - 1, start);" line273="            moveMotorZIP.brightness = this.brightness;" line272="            moveMotorZIP.pin = this.pin;" line271="            moveMotorZIP.buf = this.buf;" line270="            let moveMotorZIP = new MoveMotorZIP();" line269="            length = length &gt;&gt; 0;" line268="            start = start &gt;&gt; 0;" line267="        range(start: number, length: number): MoveMotorZIP {" line266="        //% block=&quot;%moveMotorZIP|range from %start|with %length|leds&quot;" line265="        //% blockId=&quot;kitronik_move_motor_range&quot; " line264="        //% weight=89 blockGap=8" line263="        //% group=&quot;ZIP LEDs&quot;" line262="        //% subcategory=Lights" line261="        */" line260="        * @param length number of LEDs in the range. eg: 4" line259="        * @param start offset in the LED strip to start the range" line258="        * Create a range of LEDs." line257="        /** " line256="" line255="        }" line254="            this.show();" line253="            }" line252="                }" line251="                    else this.setPixelRGB(k, 0);" line250="                    }" line249="                        this.setPixelRGB(k, rgb(g, 255 - g, 0));" line248="                        //this.setPixelRGB(i, moveMotorZIP.rgb(0, g, 255 - g));" line247="                        const g = Math.idiv(k * 255, n1);" line246="                    if (k &lt;= v) {" line245="                for (let k = 0; k &lt; n; ++k) {" line244="            } else {" line243="                    this.setPixelRGB(j, 0);" line242="                for (let j = 1; j &lt; n; ++j)" line241="                this.setPixelRGB(0, 0x666600);" line240="            if (v == 0) {" line239="            let v = Math.idiv((value * n), high);" line238="            const n1 = n - 1;" line237="            const n = this._length;" line236="            value = Math.abs(value);" line235="" line234="            }" line233="                return;" line232="                this.show();" line231="                this.setPixelRGB(0, 0xFFFF00);" line230="                this.clear();" line229="            if (high &lt;= 0) {" line228="        showBarGraph(value: number, high: number): void {" line227="        //% block=&quot;%moveMotorZIP|show bar graph of %value|up to %high&quot;" line226="        //% blockId=kitronik_move_motor_show_bar_graph " line225="        //% weight=84 blockGap=8" line224="        //% group=&quot;ZIP LEDs&quot;" line223="        //% subcategory=Lights" line222="         */" line221="         * @param high maximum value, eg: 255" line220="         * @param value current value to plot" line219="         * If `high` is 0, the chart gets adjusted automatically." line218="         * Displays a vertical bar graph based on the `value` and `high` value." line217="&#9;&#9;/**" line216="" line215="        }" line214="            this.show();" line213="            }" line212="                this.setPixelRGB(steps - 1, hsl(endHue, saturation, luminance));" line211="                }" line210="                    this.setPixelRGB(i, hsl(h, s, l));" line209="                    const l = Math.idiv((l1_100 + i * lStep), 100);" line208="                    const s = Math.idiv((s1_100 + i * sStep), 100);" line207="                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;" line206="                for (let i = 1; i &lt; steps - 1; i++) {" line205="                this.setPixelRGB(0, hsl(startHue, saturation, luminance));" line204="            } else {" line203="                this.setPixelRGB(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line202="            if (steps === 1) {" line201="            //interpolate" line200="" line199="            const l1_100 = l1 * 100" line198="            const lStep = Math.idiv(lDist, steps);" line197="            const lDist = l2 - l1;" line196="            const l2 = luminance;" line195="            const l1 = luminance;" line194="            //lum" line193="" line192="            const s1_100 = s1 * 100;" line191="            const sStep = Math.idiv(sDist, steps);" line190="            const sDist = s2 - s1;" line189="            const s2 = saturation;" line188="            const s1 = saturation;" line187="            //sat" line186="" line185="            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line184="            }" line183="                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line182="            } else {" line181="                hStep = hStepCCW;" line180="            } else if (direction === HueInterpolationDirection.CounterClockwise) {" line179="                hStep = hStepCW;" line178="            if (direction === HueInterpolationDirection.Clockwise) {" line177="            let hStep: number;" line176="            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line175="            const hDistCCW = ((h1 + 360) - h2) % 360;" line174="            const hStepCW = Math.idiv((hDistCW * 100), steps);" line173="            const hDistCW = ((h2 + 360) - h1) % 360;" line172="            const h2 = endHue;" line171="            const h1 = startHue;" line170="            //hue" line169="" line168="            const direction = HueInterpolationDirection.Clockwise;" line167="            const steps = this._length;" line166="            const luminance = 50;" line165="            const saturation = 100;" line164="            endHue = endHue &gt;&gt; 0;" line163="            startHue = startHue &gt;&gt; 0;" line162="" line161="            if (this._length &lt;= 0) return;" line160="        showRainbow(startHue: number = 1, endHue: number = 360) {" line159="        //% weight=94 blockGap=8" line158="        //% block=&quot;%moveMotorZIP|show rainbow from %startHue|to %endHue&quot;" line157="        //% blockId=&quot;kitronik_move_motor_rainbow&quot; 7" line156="        //% group=&quot;ZIP LEDs&quot;" line155="        //% subcategory=Lights" line154="         */" line153="         * @param endHue the end hue value for the rainbow, eg: 360" line152="         * @param startHue the start hue value for the rainbow, eg: 1" line151="         * Shows a rainbow pattern on all LEDs. " line150="        /**" line149="" line148="" line147="        _length: number;" line146="        start: number;" line145="        brightness: number;" line144="        pin: DigitalPin;" line143="        buf: Buffer;" line142="    export class MoveMotorZIP {" line141="" line140="    }" line139="        }" line138="            pins.digitalWritePin(DigitalPin.P12, 0);" line137="        else {" line136="        }" line135="            pins.digitalWritePin(DigitalPin.P12, 1);" line134="        if (illuminate == OnOffSelection.On) {" line133="    export function shineTailLight(illuminate: OnOffSelection): void {" line132="    //% block=&quot;turn tail light %illuminate&quot;" line131="    //% weight=95 blockGap=8" line130="    //% blockId=kitronik_move_motor_tail_light" line129="    //% group=&quot;Tail Lights&quot;" line128="    //% subcategory=Lights" line127="    */" line126="    * @param motor which motor to turn off" line125="    * Turns on and off the horn." line124="    /**" line123="" line122="    //////////////" line121="    //  LIGHTS  //" line120="    //////////////" line119="" line118="    }" line117="        initalised = true" line116="        sensorRightRef = pins.analogReadPin(AnalogPin.P2)" line115="        sensorLeftRef = pins.analogReadPin(AnalogPin.P1)" line114="" line113="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line112="        buf[1] = LED_OUT_VALUE" line111="        buf[0] = LED_OUT_ADDR" line110="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line109="        buf[1] = MODE_2_REG_VALUE" line108="        buf[0] = MODE_2_REG_ADDR" line107="        pins.i2cWriteBuffer(CHIP_ADDR, buf, false)" line106="        buf[1] = MODE_1_REG_VALUE" line105="        buf[0] = MODE_1_REG_ADDR" line104="" line103="        let buf = pins.createBuffer(2)" line102="    function setup(): void {" line101="    */" line100="&#9;&#9;This secret incantation sets up the PCA9632 I2C driver chip to be running " line99="&#9;/*" line98="" line97="" line96="    let detectionLevel = 45&#9;&#9;//reading is done by converting 0.13V into ADC reading (3/1024)*45, this is the default setting" line95="    let sensorRightRef = 0" line94="    let sensorLeftRef = 0" line93="    //Line following sensors global variables" line92="    let echoPin = DigitalPin.P14" line91="    let triggerPin = DigitalPin.P13" line90="    //Ultrasonic global variables" line89="    let sirenOn = false" line88="    //Motor global variables" line87="    let initalised = false //a flag to allow us to initialise without explicitly calling the secret incantation" line86="" line85="    }" line84="        Dark" line83="        //% block=&quot;Dark&quot;" line82="        Light," line81="        //% block=&quot;Light&quot;" line80="    export enum LightSelection {" line79="    //Light level detection mode selection" line78="    }" line77="        right" line76="        //% block=&quot;right&quot;" line75="        left," line74="        //% block=&quot;left&quot;" line73="    export enum LfSensor {" line72="    // Selection of line following sensor" line71="    /*LINE FOLLOWING*/" line70="" line69="    }" line68="        Inches" line67="        //% block=&quot;inches&quot;" line66="        Centimeters," line65="        //% block=&quot;cm&quot;" line64="    export enum Units {" line63="    // Units for ultrasonic sensors to measure" line62="    /*ULTRASONIC*/" line61="" line60="    }" line59="        Reverse" line58="        //% block=&quot;Reverse&quot;" line57="        Forward," line56="        //% block=&quot;Forward&quot;" line55="    export enum MotorDirection {" line54="    // Directions the motors can rotate." line53="    }" line52="        MotorRight = 0x04" line51="        //% block=&quot;Right&quot;" line50="        MotorLeft = 0x02," line49="        //% block=&quot;Left&quot;" line48="    export enum Motors {" line47="    // List of motors for the motor blocks to use. These represent register offsets in the PCA9865 driver IC." line46="    /*MOTORS*/" line45="" line44="    }" line43="        Black = 0x000000" line42="        //% block=black" line41="        White = 0xFFFFFF," line40="        //% block=white" line39="        Purple = 0xFF00FF," line38="        //% block=purple" line37="        Violet = 0x8a2be2," line36="        //% block=violet" line35="        Indigo = 0x4b0082," line34="        //% block=indigo" line33="        Blue = 0x0000FF," line32="        //% block=blue" line31="        Green = 0x00FF00," line30="        //% block=green" line29="        Yellow = 0xFFFF00," line28="        //% block=yellow" line27="        Orange = 0xFFA500," line26="        //% block=orange" line25="        Red = 0xFF0000," line24="        //% block=red" line23="    enum ZipLedColors {" line22="    //Well known colors for ZIP LEDs" line21="    /* ZIPLEDS*/" line20="" line19="    }" line18="        Off = 0" line17="        //% block=&quot;off&quot;" line16="        On = 1," line15="        //% block=&quot;on&quot;" line14="    export enum OnOffSelection {" line13="    /*GENERAL*/" line12="" line11="    let MOTOR_DUTY_CYCLE_RATION = 0.4" line10="" line9="    let LED_OUT_VALUE = 0xAA  //The mode 1 register address" line8="    let MODE_2_REG_VALUE = 0x10  //The mode 1 register address" line7="    let MODE_1_REG_VALUE = 0x00 //the prescale register address" line6="" line5="    let LED_OUT_ADDR = 0x08  //LED output register address" line4="    let MODE_2_REG_ADDR = 0x01  //mode 2 register address" line3="    let MODE_1_REG_ADDR = 0x00 //mode 1 register address" line2="    let CHIP_ADDR = 0xE0 // CHIP_ADDR is the standard chip address for the PCA9632" line1="    //Constants " line0="namespace Kitronik_Move_Motor {" numlines="779" line777="" line778="}"></mutation><comment id="undefined" h="80" pinned="false" w="160">% weight=100 color=#00A654 icon="\uf1b9" % block="Move Motor" % groups='["Lights", "Sensors", "Motors", "Sound"]'</comment><data>0</data></block></statement></block></xml>